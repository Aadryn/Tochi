# TÃ¢che 067.1 - Authorization Domain Layer

## PRIORITÃ‰
ðŸ”´ **P1 - CRITIQUE** (Fondation de 067)

## OBJECTIF

CrÃ©er le Domain Layer de l'application Authorization autonome avec :
- EntitÃ©s : Principal (sync IDP), RoleDefinition, RoleAssignment
- Value Objects : PrincipalId, Scope (format URL REST), Permission
- Ã‰vÃ©nements de domaine

## PRINCIPES CLÃ‰S

### 1. Principals depuis IDP Externe

Les principals ne sont **pas crÃ©Ã©s** dans l'application. Ils sont **synchronisÃ©s** depuis un IDP externe.

```csharp
// Principal.cs - EntitÃ© synchronisÃ©e depuis IDP
public sealed class Principal : Entity<PrincipalId>
{
    /// <summary>
    /// ObjectId (GUID) provenant de l'IDP externe.
    /// </summary>
    public Guid ObjectId => Id.Value;
    
    public PrincipalType Type { get; private set; }
    
    /// <summary>
    /// Identifiant dans l'IDP (email, UPN, nom de groupe, client_id).
    /// </summary>
    public string ExternalId { get; private set; }
    
    public string DisplayName { get; private set; }
    public string? Email { get; private set; }
    
    /// <summary>
    /// Source IDP (azure-ad, okta, keycloak, etc.)
    /// </summary>
    public string IdpSource { get; private set; }
    
    /// <summary>
    /// DerniÃ¨re synchronisation depuis l'IDP.
    /// </summary>
    public DateTime SyncedAt { get; private set; }
    
    public bool IsActive { get; private set; }
    
    private Principal() { }
    
    /// <summary>
    /// Synchronise un principal depuis l'IDP.
    /// CrÃ©e ou met Ã  jour les informations.
    /// </summary>
    public static Principal SyncFromIdp(
        Guid objectId,
        PrincipalType type,
        string externalId,
        string displayName,
        string? email,
        string idpSource)
    {
        return new Principal
        {
            Id = PrincipalId.From(objectId),
            Type = type,
            ExternalId = externalId,
            DisplayName = displayName,
            Email = email,
            IdpSource = idpSource,
            SyncedAt = DateTime.UtcNow,
            IsActive = true
        };
    }
    
    public void UpdateFromIdp(string displayName, string? email)
    {
        DisplayName = displayName;
        Email = email;
        SyncedAt = DateTime.UtcNow;
        
        AddDomainEvent(new PrincipalSynced(Id, IdpSource));
    }
    
    public void Deactivate()
    {
        IsActive = false;
        SyncedAt = DateTime.UtcNow;
    }
}
```

### 2. Scope au Format URL REST

```csharp
// Scope.cs - Format URL REST avec hÃ©ritage
public sealed class Scope : ValueObject
{
    /// <summary>
    /// Chemin complet du scope (format URL REST).
    /// Exemple : "api.llmproxy.com/organizations/org-123/tenants/tenant-456"
    /// </summary>
    public string Path { get; }
    
    /// <summary>
    /// Segments du scope (domain â†’ resource â†’ sub-resource â†’ ...).
    /// </summary>
    public IReadOnlyList<ScopeSegment> Segments { get; }
    
    /// <summary>
    /// Domaine racine (ex: "api.llmproxy.com").
    /// </summary>
    public string Domain => Segments.FirstOrDefault()?.Value ?? string.Empty;
    
    private Scope(string path, IReadOnlyList<ScopeSegment> segments)
    {
        Path = path;
        Segments = segments;
    }
    
    /// <summary>
    /// Parse un scope depuis une chaÃ®ne URL.
    /// </summary>
    public static Scope Parse(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            throw new ArgumentException("Scope path cannot be empty", nameof(path));
        
        var parts = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
        var segments = new List<ScopeSegment>();
        
        // Premier segment = domaine
        if (parts.Length > 0)
            segments.Add(new ScopeSegment("domain", parts[0]));
        
        // Segments suivants = type/valeur en alternance
        for (int i = 1; i < parts.Length; i += 2)
        {
            var type = parts[i];
            var value = i + 1 < parts.Length ? parts[i + 1] : null;
            segments.Add(new ScopeSegment(type, value));
        }
        
        return new Scope(path, segments);
    }
    
    /// <summary>
    /// CrÃ©e un scope racine (domaine uniquement).
    /// </summary>
    public static Scope Root(string domain) 
        => new(domain, new[] { new ScopeSegment("domain", domain) });
    
    /// <summary>
    /// CrÃ©e un scope enfant en ajoutant un segment.
    /// </summary>
    public Scope Child(string resourceType, string resourceId)
    {
        var newPath = $"{Path}/{resourceType}/{resourceId}";
        var newSegments = Segments.Append(new ScopeSegment(resourceType, resourceId)).ToList();
        return new Scope(newPath, newSegments);
    }
    
    /// <summary>
    /// Retourne le scope parent (un niveau au-dessus).
    /// </summary>
    public Scope? Parent()
    {
        if (Segments.Count <= 1) return null;
        
        var parentSegments = Segments.Take(Segments.Count - 1).ToList();
        var parentPath = string.Join("/", parentSegments.Select(s => 
            s.Value != null ? $"{s.Type}/{s.Value}" : s.Type));
        
        return new Scope(parentPath, parentSegments);
    }
    
    /// <summary>
    /// VÃ©rifie si ce scope contient (englobe) un autre scope.
    /// UtilisÃ© pour l'hÃ©ritage des permissions.
    /// </summary>
    public bool Contains(Scope other)
    {
        if (other.Path.Length < Path.Length) return false;
        return other.Path.StartsWith(Path, StringComparison.OrdinalIgnoreCase);
    }
    
    /// <summary>
    /// Retourne tous les scopes parents (du plus spÃ©cifique au plus gÃ©nÃ©ral).
    /// </summary>
    public IEnumerable<Scope> GetHierarchy()
    {
        var current = this;
        while (current != null)
        {
            yield return current;
            current = current.Parent();
        }
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Path.ToLowerInvariant();
    }
    
    public override string ToString() => Path;
}

public readonly record struct ScopeSegment(string Type, string? Value);
```

### 3. PrincipalId (ObjectId GUID)

```csharp
// PrincipalId.cs - Wrapper sur GUID (ObjectId de l'IDP)
public readonly record struct PrincipalId
{
    /// <summary>
    /// ObjectId (GUID) du principal, provenant de l'IDP.
    /// </summary>
    public Guid Value { get; }
    
    private PrincipalId(Guid value)
    {
        if (value == Guid.Empty)
            throw new ArgumentException("PrincipalId cannot be empty", nameof(value));
        Value = value;
    }
    
    public static PrincipalId From(Guid objectId) => new(objectId);
    
    public static PrincipalId Parse(string value)
    {
        if (!Guid.TryParse(value, out var guid))
            throw new ArgumentException($"Invalid ObjectId format: {value}");
        return new PrincipalId(guid);
    }
    
    public static bool TryParse(string value, out PrincipalId principalId)
    {
        if (Guid.TryParse(value, out var guid) && guid != Guid.Empty)
        {
            principalId = new PrincipalId(guid);
            return true;
        }
        principalId = default;
        return false;
    }
    
    public override string ToString() => Value.ToString();
    
    public static implicit operator Guid(PrincipalId id) => id.Value;
    public static implicit operator PrincipalId(Guid guid) => From(guid);
}
```

## STRUCTURE DE FICHIERS

```
authorization/src/Authorization.Domain/
â”œâ”€â”€ Authorization.Domain.csproj
â”œâ”€â”€ Entities/
â”‚   â”œâ”€â”€ Principal.cs           # SynchronisÃ© depuis IDP
â”‚   â”œâ”€â”€ GroupMembership.cs     # Relation groupe-membre (depuis IDP)
â”‚   â”œâ”€â”€ RoleDefinition.cs
â”‚   â””â”€â”€ RoleAssignment.cs
â”œâ”€â”€ ValueObjects/
â”‚   â”œâ”€â”€ PrincipalId.cs         # Wrapper sur GUID (ObjectId IDP)
â”‚   â”œâ”€â”€ PrincipalType.cs       # User, Group, ServiceAccount
â”‚   â”œâ”€â”€ Scope.cs               # Format URL REST
â”‚   â”œâ”€â”€ ScopeSegment.cs
â”‚   â””â”€â”€ Permission.cs          # Action + ResourceType
â”œâ”€â”€ Events/
â”‚   â”œâ”€â”€ PrincipalSynced.cs
â”‚   â”œâ”€â”€ RoleAssignmentCreated.cs
â”‚   â””â”€â”€ RoleAssignmentRevoked.cs
â”œâ”€â”€ Interfaces/
â”‚   â”œâ”€â”€ IPrincipalRepository.cs
â”‚   â”œâ”€â”€ IRoleDefinitionRepository.cs
â”‚   â””â”€â”€ IRoleAssignmentRepository.cs
â””â”€â”€ Exceptions/
    â””â”€â”€ DomainException.cs
```

## IMPLÃ‰MENTATION DÃ‰TAILLÃ‰E

### RoleDefinition

```csharp
public sealed class RoleDefinition : Entity<Guid>
{
    public string Name { get; private set; }
    public string Description { get; private set; }
    public bool IsBuiltIn { get; private set; }
    
    private readonly List<Permission> _permissions = new();
    public IReadOnlyList<Permission> Permissions => _permissions.AsReadOnly();
    
    /// <summary>
    /// Types de ressources sur lesquels ce rÃ´le peut Ãªtre assignÃ©.
    /// Ex: ["organizations", "tenants"] pour un rÃ´le tenant-level.
    /// </summary>
    private readonly List<string> _assignableResourceTypes = new();
    public IReadOnlyList<string> AssignableResourceTypes => _assignableResourceTypes.AsReadOnly();
    
    public DateTime CreatedAt { get; private set; }
    
    public static RoleDefinition CreateBuiltIn(
        string name,
        string description,
        IEnumerable<Permission> permissions,
        IEnumerable<string> assignableResourceTypes)
    {
        return new RoleDefinition
        {
            Id = Guid.NewGuid(),
            Name = name,
            Description = description,
            IsBuiltIn = true,
            _permissions = { permissions },
            _assignableResourceTypes = { assignableResourceTypes },
            CreatedAt = DateTime.UtcNow
        };
    }
    
    public bool HasPermission(string action, string resourceType)
        => _permissions.Any(p => p.Matches(action, resourceType));
}
```

### RoleAssignment

```csharp
public sealed class RoleAssignment : Entity<Guid>
{
    /// <summary>
    /// ObjectId du principal (User, Group, ou ServiceAccount).
    /// </summary>
    public PrincipalId PrincipalId { get; private set; }
    
    public Guid RoleDefinitionId { get; private set; }
    
    /// <summary>
    /// Scope au format URL REST sur lequel le rÃ´le est assignÃ©.
    /// </summary>
    public Scope Scope { get; private set; }
    
    public DateTime CreatedAt { get; private set; }
    public PrincipalId CreatedBy { get; private set; }
    public DateTime? ExpiresAt { get; private set; }
    
    public bool IsExpired => ExpiresAt.HasValue && ExpiresAt.Value < DateTime.UtcNow;
    
    public static RoleAssignment Create(
        PrincipalId principalId,
        Guid roleDefinitionId,
        Scope scope,
        PrincipalId createdBy,
        DateTime? expiresAt = null)
    {
        var assignment = new RoleAssignment
        {
            Id = Guid.NewGuid(),
            PrincipalId = principalId,
            RoleDefinitionId = roleDefinitionId,
            Scope = scope,
            CreatedBy = createdBy,
            ExpiresAt = expiresAt,
            CreatedAt = DateTime.UtcNow
        };
        
        assignment.AddDomainEvent(new RoleAssignmentCreated(
            assignment.Id,
            principalId,
            roleDefinitionId,
            scope,
            createdBy));
        
        return assignment;
    }
}
```

### Permission

```csharp
public sealed class Permission : ValueObject
{
    public string Action { get; }       // "read", "write", "delete", "admin", "*"
    public string ResourceType { get; } // "providers", "routes", "tenants", "*"
    
    private Permission(string action, string resourceType)
    {
        Action = action.ToLowerInvariant();
        ResourceType = resourceType.ToLowerInvariant();
    }
    
    public static Permission Create(string action, string resourceType) 
        => new(action, resourceType);
    
    public static Permission All => new("*", "*");
    
    public bool Matches(string action, string resourceType)
    {
        var actionMatch = Action == "*" || Action == action.ToLowerInvariant();
        var resourceMatch = ResourceType == "*" || ResourceType == resourceType.ToLowerInvariant();
        return actionMatch && resourceMatch;
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Action;
        yield return ResourceType;
    }
}
```

### Events

```csharp
public sealed record PrincipalSynced(
    PrincipalId PrincipalId,
    string IdpSource
) : IDomainEvent;

public sealed record RoleAssignmentCreated(
    Guid AssignmentId,
    PrincipalId PrincipalId,
    Guid RoleDefinitionId,
    Scope Scope,
    PrincipalId CreatedBy
) : IDomainEvent;

public sealed record RoleAssignmentRevoked(
    Guid AssignmentId,
    PrincipalId PrincipalId,
    PrincipalId RevokedBy
) : IDomainEvent;
```

### Interfaces Repository

```csharp
public interface IPrincipalRepository
{
    Task<Principal?> GetByIdAsync(PrincipalId objectId, CancellationToken ct = default);
    Task<Principal?> GetByExternalIdAsync(string externalId, string idpSource, CancellationToken ct = default);
    Task<IReadOnlyList<PrincipalId>> GetGroupMembersAsync(PrincipalId groupId, CancellationToken ct = default);
    Task<IReadOnlyList<PrincipalId>> GetGroupsForPrincipalAsync(PrincipalId principalId, CancellationToken ct = default);
    Task UpsertAsync(Principal principal, CancellationToken ct = default);
}

public interface IRoleDefinitionRepository
{
    Task<RoleDefinition?> GetByIdAsync(Guid id, CancellationToken ct = default);
    Task<RoleDefinition?> GetByNameAsync(string name, CancellationToken ct = default);
    Task<IReadOnlyList<RoleDefinition>> GetAllAsync(bool includeBuiltIn = true, CancellationToken ct = default);
    Task AddAsync(RoleDefinition role, CancellationToken ct = default);
}

public interface IRoleAssignmentRepository
{
    Task<RoleAssignment?> GetByIdAsync(Guid id, CancellationToken ct = default);
    Task<IReadOnlyList<RoleAssignment>> GetByPrincipalAsync(PrincipalId principalId, CancellationToken ct = default);
    Task<IReadOnlyList<RoleAssignment>> GetByPrincipalsAsync(IEnumerable<PrincipalId> principalIds, CancellationToken ct = default);
    Task<IReadOnlyList<RoleAssignment>> GetByScopeAsync(Scope scope, CancellationToken ct = default);
    Task AddAsync(RoleAssignment assignment, CancellationToken ct = default);
    Task DeleteAsync(Guid id, CancellationToken ct = default);
}
```

## CRITÃˆRES DE SUCCÃˆS

- [ ] Projet crÃ©Ã© dans `authorization/src/Authorization.Domain/`
- [ ] Principal avec sync depuis IDP (pas de crÃ©ation native)
- [ ] Scope au format URL REST avec hÃ©ritage
- [ ] PrincipalId basÃ© sur ObjectId (GUID)
- [ ] Ã‰vÃ©nements de domaine dÃ©finis
- [ ] Tests unitaires complets
- [ ] Build : 0 erreurs, 0 warnings

## ESTIMATION

**Effort** : 6h
**ComplexitÃ©** : Moyenne

## DÃ‰PENDANCES

Aucune - Peut Ãªtre dÃ©marrÃ©e immÃ©diatement

## TRACKING
