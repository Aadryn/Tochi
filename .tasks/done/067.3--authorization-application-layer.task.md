# TÃ¢che 067.3 - Authorization Application Layer (Couche d'IntermÃ©diation Enrichie)

## PRIORITÃ‰
ğŸŸ  **P2 - HAUTE** (DÃ©pend de 067.1 et 067.2)

## OBJECTIF

ImplÃ©menter la couche Application comme **couche d'intermÃ©diation enrichie** sur OpenFGA :
- **Validation des donnÃ©es** avant Ã©criture dans OpenFGA
- **VÃ©rification anti-doublons** pour Ã©viter les tuples dupliquÃ©es
- **DÃ©lÃ©gation hiÃ©rarchique** (owner dÃ©lÃ¨gue uniquement rÃ´les â‰¤ sien)
- **Multi-rÃ´les par scope** (cumul des permissions)
- **RÃ´les custom** (CRUD via API)
- **Permissions granulaires** (resource:action)
- **Expiration optionnelle** des assignations
- **Audit logging** (logs + PostgreSQL)
- Mapping DTOs â†” Tuples OpenFGA

## DÃ‰CISIONS DE CADRAGE APPLIQUÃ‰ES

| DÃ©cision | Impact sur Application Layer |
|----------|-----------------------------|
| Multi-rÃ´les par scope | Pas de contrainte "1 rÃ´le unique", cumul autorisÃ© |
| DÃ©lÃ©gation hiÃ©rarchique | Validation caller peut assigner ce rÃ´le |
| RÃ´les custom | CustomRoleService (CRUD) |
| Permissions granulaires | PermissionService (resource:action) |
| Expiration | ExpiresAt optionnel + support cleanup job |
| Scopes explicites | ScopeService avec crÃ©ation obligatoire |
| Audit | AuditService (logs + PostgreSQL) |

## DÃ‰PENDANCES

- âœ… **067.1** - Domain Layer (DTOs, Value Objects)
- âœ… **067.2** - Infrastructure Layer (OpenFgaService)

## ARCHITECTURE

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Authorization.Application                      â”‚
â”‚                  (Couche d'IntermÃ©diation)                       â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                    Application Services                   â”‚  â”‚
â”‚   â”‚                                                           â”‚  â”‚
â”‚   â”‚  ResponsabilitÃ©s :                                       â”‚  â”‚
â”‚   â”‚  â€¢ Validation format (ObjectId, Scope URL REST)          â”‚  â”‚
â”‚   â”‚  â€¢ Anti-doublons (Read avant Write)                      â”‚  â”‚
â”‚   â”‚  â€¢ Contraintes mÃ©tier (1 rÃ´le/scope)                     â”‚  â”‚
â”‚   â”‚  â€¢ CohÃ©rence (tuples parent automatiques)                â”‚  â”‚
â”‚   â”‚  â€¢ Audit logging                                         â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                  Infrastructure Layer                     â”‚  â”‚
â”‚   â”‚                                                           â”‚  â”‚
â”‚   â”‚  IOpenFgaService â†’ OpenFGA                               â”‚  â”‚
â”‚   â”‚  IPermissionCache â†’ Redis                                â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## STRUCTURE DE FICHIERS

```
authorization/src/Authorization.Application/
â”œâ”€â”€ Authorization.Application.csproj
â”œâ”€â”€ DependencyInjection.cs
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ IAuthorizationService.cs
â”‚   â”œâ”€â”€ AuthorizationService.cs
â”‚   â”œâ”€â”€ IRoleAssignmentService.cs
â”‚   â”œâ”€â”€ RoleAssignmentService.cs
â”‚   â”œâ”€â”€ ICustomRoleService.cs         # NOUVEAU - RÃ´les custom
â”‚   â”œâ”€â”€ CustomRoleService.cs
â”‚   â”œâ”€â”€ IPermissionService.cs         # NOUVEAU - Permissions granulaires
â”‚   â”œâ”€â”€ PermissionService.cs
â”‚   â”œâ”€â”€ IDelegationService.cs         # NOUVEAU - DÃ©lÃ©gation hiÃ©rarchique
â”‚   â”œâ”€â”€ DelegationService.cs
â”‚   â”œâ”€â”€ IAuditService.cs              # NOUVEAU - Audit (logs + PostgreSQL)
â”‚   â”œâ”€â”€ AuditService.cs
â”‚   â”œâ”€â”€ IGroupService.cs
â”‚   â”œâ”€â”€ GroupService.cs
â”‚   â”œâ”€â”€ IScopeService.cs
â”‚   â””â”€â”€ ScopeService.cs
â”œâ”€â”€ DTOs/
â”‚   â”œâ”€â”€ CheckPermissionRequest.cs
â”‚   â”œâ”€â”€ CheckPermissionResponse.cs
â”‚   â”œâ”€â”€ RoleAssignmentDto.cs
â”‚   â”œâ”€â”€ AssignRoleRequest.cs          # Enrichi avec ExpiresAt
â”‚   â”œâ”€â”€ CustomRoleDto.cs              # NOUVEAU
â”‚   â”œâ”€â”€ CreateCustomRoleRequest.cs    # NOUVEAU
â”‚   â”œâ”€â”€ PermissionDto.cs              # NOUVEAU
â”‚   â”œâ”€â”€ GroupMembershipDto.cs
â”‚   â””â”€â”€ ScopeDto.cs
â”œâ”€â”€ Validation/
â”‚   â”œâ”€â”€ AssignRoleValidator.cs
â”‚   â”œâ”€â”€ DelegationValidator.cs        # NOUVEAU
â”‚   â”œâ”€â”€ ScopeValidator.cs
â”‚   â””â”€â”€ DuplicateChecker.cs
â””â”€â”€ Exceptions/
    â”œâ”€â”€ DuplicateAssignmentException.cs
    â”œâ”€â”€ InvalidScopeException.cs
    â”œâ”€â”€ InvalidRoleException.cs
    â”œâ”€â”€ DelegationForbiddenException.cs  # NOUVEAU
    â””â”€â”€ ScopeNotCreatedException.cs      # NOUVEAU
```

## IMPLÃ‰MENTATION

### 1. Authorization Service (Check)

```csharp
// Services/IAuthorizationService.cs
public interface IAuthorizationService
{
    Task<CheckPermissionResponse> CheckAsync(
        CheckPermissionRequest request,
        CancellationToken ct = default);
    
    Task<IReadOnlyList<string>> ListPermissionsAsync(
        PrincipalId principalId,
        Scope scope,
        CancellationToken ct = default);
    
    Task<IReadOnlyList<string>> ListAccessibleScopesAsync(
        PrincipalId principalId,
        string permission,
        CancellationToken ct = default);
}

// DTOs/CheckPermissionRequest.cs
public sealed record CheckPermissionRequest(
    PrincipalId PrincipalId,
    string Permission,
    Scope Scope);

// DTOs/CheckPermissionResponse.cs
public sealed record CheckPermissionResponse(
    bool Allowed,
    string? Reason = null);
```

```csharp
// Services/AuthorizationService.cs
public sealed class AuthorizationService : IAuthorizationService
{
    private readonly IOpenFgaService _openFga;
    private readonly IPermissionCache _cache;
    
    public AuthorizationService(
        IOpenFgaService openFga,
        IPermissionCache cache)
    {
        _openFga = openFga;
        _cache = cache;
    }
    
    public async Task<CheckPermissionResponse> CheckAsync(
        CheckPermissionRequest request,
        CancellationToken ct = default)
    {
        var user = $"user:{request.PrincipalId.Value}";
        var relation = request.Permission;
        var obj = $"scope:{request.Scope.Path}";
        
        // Check cache first
        var cached = await _cache.GetCheckResultAsync(user, relation, obj, ct);
        if (cached.HasValue)
            return new CheckPermissionResponse(cached.Value, "cached");
        
        // Check OpenFGA
        var allowed = await _openFga.CheckAsync(user, relation, obj, ct);
        
        // Cache result
        await _cache.SetCheckResultAsync(
            user, relation, obj,
            allowed, TimeSpan.FromMinutes(5), ct);
        
        return new CheckPermissionResponse(allowed);
    }
    
    public async Task<IReadOnlyList<string>> ListPermissionsAsync(
        PrincipalId principalId,
        Scope scope,
        CancellationToken ct = default)
    {
        var user = $"user:{principalId.Value}";
        var obj = $"scope:{scope.Path}";
        var permissions = new List<string>();
        
        // Check each permission
        foreach (var permission in new[] { "can_read", "can_write", "can_delete", "can_manage" })
        {
            if (await _openFga.CheckAsync(user, permission, obj, ct))
                permissions.Add(permission);
        }
        
        return permissions;
    }
    
    public async Task<IReadOnlyList<string>> ListAccessibleScopesAsync(
        PrincipalId principalId,
        string permission,
        CancellationToken ct = default)
    {
        var user = $"user:{principalId.Value}";
        return await _openFga.ListObjectsAsync(user, permission, "scope", ct);
    }
}
```

### 2. Role Assignment Service

```csharp
// Services/IRoleAssignmentService.cs
public interface IRoleAssignmentService
{
    Task<RoleAssignmentDto> AssignAsync(
        AssignRoleRequest request,
        CancellationToken ct = default);
    
    Task RevokeAsync(
        PrincipalId principalId,
        string role,
        Scope scope,
        CancellationToken ct = default);
    
    Task<IReadOnlyList<RoleAssignmentDto>> ListByPrincipalAsync(
        PrincipalId principalId,
        CancellationToken ct = default);
    
    Task<IReadOnlyList<RoleAssignmentDto>> ListByScopeAsync(
        Scope scope,
        CancellationToken ct = default);
}

// DTOs/AssignRoleRequest.cs
public sealed record AssignRoleRequest(
    PrincipalId PrincipalId,
    PrincipalType PrincipalType,
    string Role,
    Scope Scope,
    DateTimeOffset? ExpiresAt = null);  // NOUVEAU - Expiration optionnelle

// DTOs/RoleAssignmentDto.cs
public sealed record RoleAssignmentDto(
    PrincipalId PrincipalId,
    PrincipalType PrincipalType,
    string Role,
    Scope Scope,
    DateTimeOffset? ExpiresAt = null,
    DateTimeOffset CreatedAt = default);
```

```csharp
// Services/RoleAssignmentService.cs
public sealed class RoleAssignmentService : IRoleAssignmentService
{
    private readonly IOpenFgaService _openFga;
    private readonly IPermissionCache _cache;
    private readonly IDelegationService _delegation;
    private readonly IAuditService _audit;
    private readonly ILogger<RoleAssignmentService> _logger;
    
    public async Task<RoleAssignmentDto> AssignAsync(
        AssignRoleRequest request,
        PrincipalId callerId,  // NOUVEAU - Qui fait l'action
        CancellationToken ct = default)
    {
        // 1. VALIDATION : VÃ©rifier le format du rÃ´le (base ou custom)
        await ValidateRoleAsync(request.Role, ct);
        
        // 2. VALIDATION : VÃ©rifier que le scope existe (explicite)
        if (!await _scopeService.ExistsAsync(request.Scope, ct))
            throw new ScopeNotCreatedException(
                $"Scope '{request.Scope.Path}' must be created before assignment");
        
        // 3. DÃ‰LÃ‰GATION : VÃ©rifier que le caller peut assigner ce rÃ´le
        await _delegation.ValidateDelegationAsync(callerId, request.Role, request.Scope, ct);
        
        // 4. ANTI-DOUBLON : VÃ©rifier si l'assignment existe dÃ©jÃ 
        var existingTuples = await _openFga.ReadAsync(
            user: GetUserString(request.PrincipalId, request.PrincipalType),
            relation: request.Role,
            @object: $"scope:{request.Scope.Path}",
            ct: ct);
        
        if (existingTuples.Any())
        {
            throw new DuplicateAssignmentException(
                $"Role '{request.Role}' already assigned to principal '{request.PrincipalId}' on scope '{request.Scope.Path}'");
        }
        
        // NOTE: Multi-rÃ´les autorisÃ© - pas de contrainte "1 rÃ´le par scope"
        
        // 5. Build tuple
        var tuple = request.PrincipalType switch
        {
            PrincipalType.User => TupleBuilder.UserAssignment(
                request.PrincipalId.Value, request.Role, request.Scope),
            PrincipalType.Group => TupleBuilder.GroupAssignment(
                request.PrincipalId.Value, request.Role, request.Scope),
            PrincipalType.ServiceAccount => new TupleKey(
                $"serviceaccount:{request.PrincipalId.Value}",
                request.Role,
                $"scope:{request.Scope.Path}"),
            _ => throw new ArgumentException("Unknown principal type")
        };
        
        // 6. Write to OpenFGA
        await _openFga.WriteTuplesAsync([tuple], ct);
        
        // 7. Invalidate cache
        await _cache.InvalidateUserAsync($"user:{request.PrincipalId.Value}", ct);
        
        // 8. AUDIT (logs + PostgreSQL)
        await _audit.LogAssignmentAsync(callerId, request, ct);
        
        return new RoleAssignmentDto(
            request.PrincipalId,
            request.PrincipalType,
            request.Role,
            request.Scope,
            request.ExpiresAt,
            DateTimeOffset.UtcNow);
    }
    
    private async Task ValidateRoleAsync(string role, CancellationToken ct)
    {
        var baseRoles = new[] { "owner", "contributor", "reader" };
        if (baseRoles.Contains(role))
            return; // RÃ´le de base valide
        
        // VÃ©rifier si c'est un rÃ´le custom existant
        var customRoleExists = await _customRoleService.ExistsAsync(role, ct);
        if (!customRoleExists)
            throw new InvalidRoleException($"Role '{role}' does not exist. Valid base roles: {string.Join(", ", baseRoles)}");
    }
}
```

### 3. Group Service

```csharp
// Services/IGroupService.cs
public interface IGroupService
{
    Task AddMemberAsync(
        PrincipalId groupId,
        PrincipalId memberId,
        CancellationToken ct = default);
    
    Task RemoveMemberAsync(
        PrincipalId groupId,
        PrincipalId memberId,
        CancellationToken ct = default);
    
    Task<IReadOnlyList<PrincipalId>> ListMembersAsync(
        PrincipalId groupId,
        CancellationToken ct = default);
}
```

```csharp
// Services/GroupService.cs
public sealed class GroupService : IGroupService
{
    private readonly IOpenFgaService _openFga;
    private readonly IPermissionCache _cache;
    
    public async Task AddMemberAsync(
        PrincipalId groupId,
        PrincipalId memberId,
        CancellationToken ct = default)
    {
        var tuple = TupleBuilder.GroupMembership(memberId.Value, groupId.Value);
        await _openFga.WriteTuplesAsync([tuple], ct);
        await _cache.InvalidateUserAsync($"user:{memberId.Value}", ct);
    }
    
    public async Task RemoveMemberAsync(
        PrincipalId groupId,
        PrincipalId memberId,
        CancellationToken ct = default)
    {
        var tuple = TupleBuilder.GroupMembership(memberId.Value, groupId.Value);
        await _openFga.DeleteTuplesAsync([tuple], ct);
        await _cache.InvalidateUserAsync($"user:{memberId.Value}", ct);
    }
    
    public async Task<IReadOnlyList<PrincipalId>> ListMembersAsync(
        PrincipalId groupId,
        CancellationToken ct = default)
    {
        var tuples = await _openFga.ReadAsync(
            relation: "member",
            @object: $"group:{groupId.Value}",
            ct: ct);
        
        return tuples
            .Select(t => PrincipalId.Create(Guid.Parse(t.User.Replace("user:", ""))))
            .ToList();
    }
}
```

### 4. Scope Service

```csharp
// Services/IScopeService.cs
public interface IScopeService
{
    Task EstablishHierarchyAsync(
        Scope child,
        Scope parent,
        CancellationToken ct = default);
    
    Task<IReadOnlyList<Scope>> GetChildrenAsync(
        Scope parent,
        CancellationToken ct = default);
}
```

```csharp
// Services/ScopeService.cs
public sealed class ScopeService : IScopeService
{
    private readonly IOpenFgaService _openFga;
    
    public async Task EstablishHierarchyAsync(
        Scope child,
        Scope parent,
        CancellationToken ct = default)
    {
        // Validate that child is descendant of parent
        if (!child.IsDescendantOf(parent))
            throw new ArgumentException($"Scope {child.Path} is not a descendant of {parent.Path}");
        
        var tuple = TupleBuilder.ScopeParent(child, parent);
        await _openFga.WriteTuplesAsync([tuple], ct);
    }
    
    public async Task<IReadOnlyList<Scope>> GetChildrenAsync(
        Scope parent,
        CancellationToken ct = default)
    {
        var tuples = await _openFga.ReadAsync(
            relation: "parent",
            @object: $"scope:{parent.Path}",
            ct: ct);
        
        return tuples
            .Select(t => Scope.Parse(t.User.Replace("scope:", "")))
            .ToList();
    }
}
```

### 5. Dependency Injection

```csharp
// DependencyInjection.cs
public static class DependencyInjection
{
    public static IServiceCollection AddAuthorizationApplication(
        this IServiceCollection services)
    {
        services.AddScoped<IAuthorizationService, AuthorizationService>();
        services.AddScoped<IRoleAssignmentService, RoleAssignmentService>();
        services.AddScoped<IGroupService, GroupService>();
        services.AddScoped<IScopeService, ScopeService>();
        
        return services;
    }
}
```

## TESTS

```csharp
[Fact]
public async Task Check_WithValidPermission_ReturnsAllowed()
{
    // Arrange
    var openFga = Substitute.For<IOpenFgaService>();
    openFga.CheckAsync(Arg.Any<string>(), Arg.Any<string>(), Arg.Any<string>())
        .Returns(true);
    
    var cache = Substitute.For<IPermissionCache>();
    cache.GetCheckResultAsync(Arg.Any<string>(), Arg.Any<string>(), Arg.Any<string>())
        .Returns((bool?)null);
    
    var service = new AuthorizationService(openFga, cache);
    
    var request = new CheckPermissionRequest(
        PrincipalId.Create(Guid.NewGuid()),
        "can_read",
        Scope.Parse("api.llmproxy.com/organizations/org-123"));
    
    // Act
    var result = await service.CheckAsync(request);
    
    // Assert
    result.Allowed.Should().BeTrue();
}

[Fact]
public async Task AssignRole_WithValidRequest_WritesToOpenFga()
{
    // Arrange
    var openFga = Substitute.For<IOpenFgaService>();
    var cache = Substitute.For<IPermissionCache>();
    var service = new RoleAssignmentService(openFga, cache);
    
    var request = new AssignRoleRequest(
        PrincipalId.Create(Guid.NewGuid()),
        PrincipalType.User,
        "contributor",
        Scope.Parse("api.llmproxy.com/organizations/org-123"));
    
    // Act
    await service.AssignAsync(request);
    
    // Assert
    await openFga.Received(1).WriteTuplesAsync(Arg.Any<IEnumerable<TupleKey>>());
    await cache.Received(1).InvalidateUserAsync(Arg.Any<string>());
}
```

## CRITÃˆRES DE SUCCÃˆS

- [ ] Projet crÃ©Ã© dans `authorization/src/Authorization.Application/`
- [ ] AuthorizationService avec Check et ListPermissions
- [ ] RoleAssignmentService avec Assign, Revoke et expiration
- [ ] DelegationService avec validation hiÃ©rarchique
- [ ] CustomRoleService (CRUD rÃ´les custom)
- [ ] PermissionService (permissions granulaires resource:action)
- [ ] AuditService (logs + PostgreSQL)
- [ ] GroupService avec AddMember et RemoveMember
- [ ] ScopeService avec crÃ©ation explicite
- [ ] DTOs enrichis (ExpiresAt, CustomRole, Permission)
- [ ] Exceptions spÃ©cialisÃ©es (Delegation, ScopeNotCreated)
- [ ] Tests unitaires avec mocks
- [ ] Build : 0 erreurs, 0 warnings

## ESTIMATION

**Effort** : 14h (+6h vs initial)
**ComplexitÃ©** : Haute

**DÃ©tail** :
- Services de base (Check, Assign, Revoke) : 4h
- DelegationService : 3h
- CustomRoleService : 3h
- PermissionService : 2h
- AuditService : 2h

## RÃ‰FÃ‰RENCES

- [ADR-060](../docs/adr/060-authorization-azure-rbac-style.adr.md)
- [OpenFGA Best Practices](https://openfga.dev/docs/best-practices)
