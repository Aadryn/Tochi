# TÃ¢che 067.4 - Authorization API Layer

## PRIORITÃ‰
ðŸŸ  **P2 - HAUTE** (DÃ©pend de 067.3)

## OBJECTIF

CrÃ©er l'API REST de l'application Authorization autonome :
- Controllers : Permissions, RoleAssignments, RoleDefinitions, Principals
- Authentification JWT (validation token IDP)
- Documentation OpenAPI
- Health checks et mÃ©triques

## DÃ‰PENDANCES

- âœ… **067.3** - Application Layer (use cases, engine)

## ENDPOINTS API

| MÃ©thode | Endpoint | Description |
|---------|----------|-------------|
| `POST` | `/api/v1/permissions/check` | VÃ©rifie une permission |
| `GET` | `/api/v1/permissions/effective` | Permissions effectives |
| `GET` | `/api/v1/assignments` | Liste les assignments |
| `POST` | `/api/v1/assignments` | CrÃ©e un assignment |
| `DELETE` | `/api/v1/assignments/{id}` | RÃ©voque un assignment |
| `GET` | `/api/v1/roles` | Liste les rÃ´les |
| `GET` | `/api/v1/roles/{id}` | DÃ©tail d'un rÃ´le |
| `POST` | `/api/v1/roles` | CrÃ©e un rÃ´le custom |
| `GET` | `/api/v1/principals/{id}` | Info d'un principal |
| `POST` | `/api/v1/principals/sync` | Sync depuis IDP |
| `GET` | `/health` | Health check |
| `GET` | `/metrics` | MÃ©triques Prometheus |

## STRUCTURE DE FICHIERS

```
authorization/src/Authorization.API/
â”œâ”€â”€ Authorization.API.csproj
â”œâ”€â”€ Program.cs
â”œâ”€â”€ appsettings.json
â”œâ”€â”€ appsettings.Development.json
â”œâ”€â”€ Controllers/
â”‚   â”œâ”€â”€ PermissionsController.cs
â”‚   â”œâ”€â”€ RoleAssignmentsController.cs
â”‚   â”œâ”€â”€ RoleDefinitionsController.cs
â”‚   â””â”€â”€ PrincipalsController.cs
â”œâ”€â”€ Contracts/
â”‚   â”œâ”€â”€ Requests/
â”‚   â”‚   â”œâ”€â”€ CheckPermissionRequest.cs
â”‚   â”‚   â”œâ”€â”€ CreateAssignmentRequest.cs
â”‚   â”‚   â”œâ”€â”€ CreateRoleRequest.cs
â”‚   â”‚   â””â”€â”€ SyncPrincipalRequest.cs
â”‚   â””â”€â”€ Responses/
â”‚       â”œâ”€â”€ PermissionCheckResponse.cs
â”‚       â”œâ”€â”€ AssignmentResponse.cs
â”‚       â”œâ”€â”€ RoleResponse.cs
â”‚       â””â”€â”€ PrincipalResponse.cs
â”œâ”€â”€ Middleware/
â”‚   â”œâ”€â”€ JwtValidationMiddleware.cs
â”‚   â””â”€â”€ ExceptionHandlerMiddleware.cs
â”œâ”€â”€ Configuration/
â”‚   â”œâ”€â”€ JwtConfiguration.cs
â”‚   â””â”€â”€ SwaggerConfiguration.cs
â””â”€â”€ Extensions/
    â”œâ”€â”€ ServiceCollectionExtensions.cs
    â””â”€â”€ ClaimsPrincipalExtensions.cs
```

## IMPLÃ‰MENTATION

### Program.cs

```csharp
using Authorization.Application;
using Authorization.Infrastructure;
using Authorization.API.Configuration;
using Authorization.API.Middleware;

var builder = WebApplication.CreateBuilder(args);

// Configuration
builder.Services.Configure<JwtConfiguration>(
    builder.Configuration.GetSection("Jwt"));

// Layers
builder.Services.AddAuthorizationInfrastructure(builder.Configuration);
builder.Services.AddAuthorizationApplication();

// API
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerConfiguration();

// Authentication (validation JWT depuis IDP)
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        var jwtConfig = builder.Configuration
            .GetSection("Jwt")
            .Get<JwtConfiguration>()!;
        
        options.Authority = jwtConfig.Authority;
        options.Audience = jwtConfig.Audience;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidIssuer = jwtConfig.Issuer,
            ValidAudience = jwtConfig.Audience
        };
    });

builder.Services.AddAuthorization();

// Health checks
builder.Services.AddHealthChecks()
    .AddNpgSql(builder.Configuration.GetConnectionString("AuthorizationDb")!)
    .AddRedis(builder.Configuration.GetConnectionString("Redis")!);

var app = builder.Build();

// Middleware
app.UseMiddleware<ExceptionHandlerMiddleware>();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.MapHealthChecks("/health");

// Apply migrations
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<AuthorizationDbContext>();
    await db.Database.MigrateAsync();
}

app.Run();
```

### PermissionsController

```csharp
[ApiController]
[Route("api/v1/permissions")]
[Authorize]
public class PermissionsController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public PermissionsController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    /// <summary>
    /// VÃ©rifie si le principal courant a une permission spÃ©cifique.
    /// </summary>
    [HttpPost("check")]
    [ProducesResponseType(typeof(PermissionCheckResponse), 200)]
    public async Task<IActionResult> CheckPermission(
        [FromBody] CheckPermissionRequest request,
        CancellationToken ct)
    {
        // ObjectId du principal depuis le token JWT
        var principalId = User.GetObjectId();
        
        var query = new CheckPermissionQuery(
            principalId,
            request.Action,
            request.ResourceType,
            request.Scope);
        
        var result = await _mediator.Send(query, ct);
        
        return Ok(new PermissionCheckResponse
        {
            IsAllowed = result.IsAllowed,
            GrantedVia = result.GrantedVia,
            Role = result.Role,
            MatchingScope = result.MatchingScope
        });
    }
    
    /// <summary>
    /// VÃ©rifie une permission pour un principal spÃ©cifique.
    /// NÃ©cessite le rÃ´le admin ou permission check:permissions.
    /// </summary>
    [HttpPost("check/principal/{principalId:guid}")]
    [ProducesResponseType(typeof(PermissionCheckResponse), 200)]
    public async Task<IActionResult> CheckPermissionForPrincipal(
        [FromRoute] Guid principalId,
        [FromBody] CheckPermissionRequest request,
        CancellationToken ct)
    {
        // TODO: VÃ©rifier que l'appelant a le droit de vÃ©rifier pour ce principal
        
        var query = new CheckPermissionQuery(
            principalId,
            request.Action,
            request.ResourceType,
            request.Scope);
        
        var result = await _mediator.Send(query, ct);
        
        return Ok(new PermissionCheckResponse
        {
            IsAllowed = result.IsAllowed,
            GrantedVia = result.GrantedVia,
            Role = result.Role,
            MatchingScope = result.MatchingScope
        });
    }
    
    /// <summary>
    /// RÃ©cupÃ¨re les permissions effectives du principal courant sur un scope.
    /// </summary>
    [HttpGet("effective")]
    [ProducesResponseType(typeof(EffectivePermissionsResponse), 200)]
    public async Task<IActionResult> GetEffectivePermissions(
        [FromQuery] string scope,
        CancellationToken ct)
    {
        var principalId = User.GetObjectId();
        
        var query = new GetEffectivePermissionsQuery(principalId, scope);
        var result = await _mediator.Send(query, ct);
        
        return Ok(new EffectivePermissionsResponse
        {
            PrincipalId = result.PrincipalId.ToString(),
            Scope = result.Scope,
            Roles = result.Roles.Select(r => new EffectiveRoleDto
            {
                Name = r.RoleName,
                AssignedScope = r.AssignedScope,
                GrantedVia = r.GrantedVia
            }).ToList(),
            Permissions = result.Permissions.Select(p => $"{p.Action}:{p.ResourceType}").ToList()
        });
    }
}
```

### RoleAssignmentsController

```csharp
[ApiController]
[Route("api/v1/assignments")]
[Authorize]
public class RoleAssignmentsController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public RoleAssignmentsController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    /// <summary>
    /// Liste les assignments de rÃ´les.
    /// Filtrable par principal ou scope.
    /// </summary>
    [HttpGet]
    [ProducesResponseType(typeof(IEnumerable<AssignmentResponse>), 200)]
    public async Task<IActionResult> ListAssignments(
        [FromQuery] Guid? principalId,
        [FromQuery] string? scope,
        CancellationToken ct)
    {
        var query = new ListAssignmentsQuery(principalId, scope);
        var result = await _mediator.Send(query, ct);
        
        return Ok(result.Select(MapToResponse));
    }
    
    /// <summary>
    /// CrÃ©e un nouvel assignment de rÃ´le.
    /// L'appelant doit avoir la permission assign:roles sur le scope.
    /// </summary>
    [HttpPost]
    [ProducesResponseType(typeof(AssignmentResponse), 201)]
    [ProducesResponseType(400)]
    [ProducesResponseType(403)]
    public async Task<IActionResult> CreateAssignment(
        [FromBody] CreateAssignmentRequest request,
        CancellationToken ct)
    {
        var callerObjectId = User.GetObjectId();
        
        // VÃ©rifier que l'appelant a le droit d'assigner sur ce scope
        var canAssign = await _mediator.Send(new CheckPermissionQuery(
            callerObjectId,
            "assign",
            "roles",
            request.Scope), ct);
        
        if (!canAssign.IsAllowed)
        {
            return Forbid();
        }
        
        var command = new AssignRoleCommand(
            request.PrincipalId,
            request.RoleName,
            request.Scope,
            callerObjectId,
            request.ExpiresAt);
        
        var result = await _mediator.Send(command, ct);
        
        if (!result.Success)
        {
            return BadRequest(new { error = result.Error });
        }
        
        return CreatedAtAction(
            nameof(GetAssignment),
            new { id = result.AssignmentId },
            new AssignmentResponse { Id = result.AssignmentId });
    }
    
    /// <summary>
    /// RÃ©cupÃ¨re un assignment par ID.
    /// </summary>
    [HttpGet("{id:guid}")]
    [ProducesResponseType(typeof(AssignmentResponse), 200)]
    [ProducesResponseType(404)]
    public async Task<IActionResult> GetAssignment(Guid id, CancellationToken ct)
    {
        var query = new GetAssignmentQuery(id);
        var result = await _mediator.Send(query, ct);
        
        if (result == null)
            return NotFound();
        
        return Ok(MapToResponse(result));
    }
    
    /// <summary>
    /// RÃ©voque un assignment.
    /// L'appelant doit avoir la permission revoke:roles sur le scope.
    /// </summary>
    [HttpDelete("{id:guid}")]
    [ProducesResponseType(204)]
    [ProducesResponseType(403)]
    [ProducesResponseType(404)]
    public async Task<IActionResult> RevokeAssignment(Guid id, CancellationToken ct)
    {
        var callerObjectId = User.GetObjectId();
        
        // RÃ©cupÃ©rer l'assignment pour vÃ©rifier le scope
        var assignment = await _mediator.Send(new GetAssignmentQuery(id), ct);
        if (assignment == null)
            return NotFound();
        
        // VÃ©rifier que l'appelant a le droit de rÃ©voquer sur ce scope
        var canRevoke = await _mediator.Send(new CheckPermissionQuery(
            callerObjectId,
            "revoke",
            "roles",
            assignment.Scope), ct);
        
        if (!canRevoke.IsAllowed)
        {
            return Forbid();
        }
        
        var command = new RevokeRoleCommand(id, callerObjectId);
        await _mediator.Send(command, ct);
        
        return NoContent();
    }
    
    private static AssignmentResponse MapToResponse(AssignmentDto dto)
    {
        return new AssignmentResponse
        {
            Id = dto.Id,
            PrincipalId = dto.PrincipalId.ToString(),
            RoleName = dto.RoleName,
            Scope = dto.Scope,
            CreatedAt = dto.CreatedAt,
            CreatedBy = dto.CreatedBy.ToString(),
            ExpiresAt = dto.ExpiresAt
        };
    }
}
```

### PrincipalsController

```csharp
[ApiController]
[Route("api/v1/principals")]
[Authorize]
public class PrincipalsController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public PrincipalsController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    /// <summary>
    /// RÃ©cupÃ¨re les informations d'un principal.
    /// </summary>
    [HttpGet("{id:guid}")]
    [ProducesResponseType(typeof(PrincipalResponse), 200)]
    [ProducesResponseType(404)]
    public async Task<IActionResult> GetPrincipal(Guid id, CancellationToken ct)
    {
        var query = new GetPrincipalQuery(id);
        var result = await _mediator.Send(query, ct);
        
        if (result == null)
            return NotFound();
        
        return Ok(new PrincipalResponse
        {
            Id = result.Id.ToString(),
            Type = result.Type.ToString(),
            ExternalId = result.ExternalId,
            DisplayName = result.DisplayName,
            Email = result.Email,
            IdpSource = result.IdpSource,
            IsActive = result.IsActive,
            SyncedAt = result.SyncedAt
        });
    }
    
    /// <summary>
    /// Synchronise un principal depuis l'IDP.
    /// AppelÃ© lors de la premiÃ¨re connexion ou mise Ã  jour.
    /// </summary>
    [HttpPost("sync")]
    [ProducesResponseType(typeof(SyncPrincipalResponse), 200)]
    [ProducesResponseType(400)]
    public async Task<IActionResult> SyncPrincipal(
        [FromBody] SyncPrincipalRequest request,
        CancellationToken ct)
    {
        var command = new SyncPrincipalCommand(
            request.ObjectId,
            request.Type,
            request.ExternalId,
            request.DisplayName,
            request.Email,
            request.IdpSource);
        
        var result = await _mediator.Send(command, ct);
        
        if (!result.Success)
        {
            return BadRequest(new { error = result.Error });
        }
        
        return Ok(new SyncPrincipalResponse
        {
            Success = true,
            Created = result.Created
        });
    }
    
    /// <summary>
    /// RÃ©cupÃ¨re les groupes auxquels appartient un principal.
    /// </summary>
    [HttpGet("{id:guid}/groups")]
    [ProducesResponseType(typeof(IEnumerable<PrincipalResponse>), 200)]
    public async Task<IActionResult> GetPrincipalGroups(Guid id, CancellationToken ct)
    {
        var query = new GetPrincipalGroupsQuery(id);
        var result = await _mediator.Send(query, ct);
        
        return Ok(result.Select(g => new PrincipalResponse
        {
            Id = g.Id.ToString(),
            Type = g.Type.ToString(),
            DisplayName = g.DisplayName,
            IdpSource = g.IdpSource
        }));
    }
}
```

### Contracts

```csharp
// Requests
public record CheckPermissionRequest(
    string Action,
    string ResourceType,
    string Scope);

public record CreateAssignmentRequest(
    Guid PrincipalId,
    string RoleName,
    string Scope,
    DateTime? ExpiresAt = null);

public record SyncPrincipalRequest(
    Guid ObjectId,
    string Type,
    string ExternalId,
    string DisplayName,
    string? Email,
    string IdpSource);

// Responses
public record PermissionCheckResponse
{
    public bool IsAllowed { get; init; }
    public string? GrantedVia { get; init; }
    public string? Role { get; init; }
    public string? MatchingScope { get; init; }
}

public record AssignmentResponse
{
    public Guid Id { get; init; }
    public string PrincipalId { get; init; } = string.Empty;
    public string RoleName { get; init; } = string.Empty;
    public string Scope { get; init; } = string.Empty;
    public DateTime CreatedAt { get; init; }
    public string CreatedBy { get; init; } = string.Empty;
    public DateTime? ExpiresAt { get; init; }
}

public record PrincipalResponse
{
    public string Id { get; init; } = string.Empty;
    public string Type { get; init; } = string.Empty;
    public string ExternalId { get; init; } = string.Empty;
    public string DisplayName { get; init; } = string.Empty;
    public string? Email { get; init; }
    public string IdpSource { get; init; } = string.Empty;
    public bool IsActive { get; init; }
    public DateTime SyncedAt { get; init; }
}
```

### JWT Configuration

```csharp
public class JwtConfiguration
{
    /// <summary>
    /// URL de l'IDP (ex: https://login.microsoftonline.com/{tenant}/v2.0)
    /// </summary>
    public string Authority { get; set; } = string.Empty;
    
    /// <summary>
    /// Issuer attendu du token.
    /// </summary>
    public string Issuer { get; set; } = string.Empty;
    
    /// <summary>
    /// Audience attendue (client_id de l'app).
    /// </summary>
    public string Audience { get; set; } = string.Empty;
}
```

### Extensions

```csharp
public static class ClaimsPrincipalExtensions
{
    /// <summary>
    /// Extrait l'ObjectId (GUID) du principal depuis les claims JWT.
    /// </summary>
    public static Guid GetObjectId(this ClaimsPrincipal principal)
    {
        // Azure AD utilise "oid" claim
        var oid = principal.FindFirstValue("oid")
            ?? principal.FindFirstValue("sub")
            ?? throw new UnauthorizedAccessException("No object ID claim found");
        
        return Guid.Parse(oid);
    }
    
    /// <summary>
    /// RÃ©cupÃ¨re l'adresse email depuis les claims.
    /// </summary>
    public static string? GetEmail(this ClaimsPrincipal principal)
    {
        return principal.FindFirstValue(ClaimTypes.Email)
            ?? principal.FindFirstValue("preferred_username")
            ?? principal.FindFirstValue("email");
    }
    
    /// <summary>
    /// RÃ©cupÃ¨re le nom d'affichage.
    /// </summary>
    public static string? GetDisplayName(this ClaimsPrincipal principal)
    {
        return principal.FindFirstValue("name")
            ?? principal.FindFirstValue(ClaimTypes.Name);
    }
}
```

### appsettings.json

```json
{
  "ConnectionStrings": {
    "AuthorizationDb": "Host=localhost;Port=5432;Database=authorization;Username=postgres;Password=postgres",
    "Redis": "localhost:6379"
  },
  "Jwt": {
    "Authority": "https://login.microsoftonline.com/{tenant}/v2.0",
    "Issuer": "https://sts.windows.net/{tenant}/",
    "Audience": "{client-id}"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

## CRITÃˆRES DE SUCCÃˆS

- [ ] Projet crÃ©Ã© dans `authorization/src/Authorization.API/`
- [ ] Controllers : Permissions, RoleAssignments, RoleDefinitions, Principals
- [ ] Authentification JWT depuis IDP
- [ ] Swagger/OpenAPI documentÃ©
- [ ] Health checks PostgreSQL + Redis
- [ ] Tests d'intÃ©gration API
- [ ] Build : 0 erreurs, 0 warnings

## ESTIMATION

**Effort** : 8h
**ComplexitÃ©** : Moyenne

## TRACKING
