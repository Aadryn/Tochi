# T√¢che 067.5 - Migration & Int√©gration Authorization

## PRIORIT√â
üî¥ **P1 - CRITIQUE** (D√©pend de 067.4)

## OBJECTIF

Migrer les donn√©es existantes, mettre √† jour le mod√®le OpenFGA, et int√©grer la nouvelle Authorization.API avec les services existants (Admin.API, Gateway).

## PHASE 1 : MISE √Ä JOUR DU MOD√àLE OPENFGA

### Nouveau Mod√®le FGA

**Note** : Dans ce nouveau mod√®le, les identifiants sont des ObjectIds (GUIDs), pas des emails.
Format des tuples : `user:{objectId}`, `group:{objectId}#member`, `service_account:{objectId}`

```fga
model
  schema 1.1

# Les identifiants user/group/service_account sont des ObjectIds (GUIDs)
# Exemple: user:550e8400-e29b-41d4-a716-446655440000

type platform
  relations
    define member: [user, group#member, service_account]
    define admin: [user, group#member, service_account]
    define viewer: [user, group#member, service_account]

type organization
  relations
    define platform: [platform]
    define member: [user, group#member, service_account] or admin or viewer
    define admin: [user, group#member, service_account] or admin from platform
    define viewer: [user, group#member, service_account]
    define operator: [user, group#member, service_account]
    define contributor: [user, group#member, service_account]
    define reader: [user, group#member, service_account]

type tenant
  relations
    define organization: [organization]
    define admin: [user, group#member, service_account] or admin from organization
    define operator: [user, group#member, service_account] or operator from organization
    define contributor: [user, group#member, service_account] or contributor from organization
    define reader: [user, group#member, service_account] or reader from organization
    define can_manage: admin
    define can_write: admin or operator or contributor
    define can_read: admin or operator or contributor or reader

type provider
  relations
    define tenant: [tenant]
    define admin: [user, group#member, service_account] or admin from tenant
    define operator: [user, group#member, service_account] or operator from tenant
    define can_manage: admin
    define can_configure: admin or operator
    define can_use: admin or operator or can_read from tenant

type route
  relations
    define tenant: [tenant]
    define admin: [user, group#member, service_account] or admin from tenant
    define contributor: [user, group#member, service_account] or contributor from tenant
    define can_manage: admin
    define can_modify: admin or contributor
    define can_use: admin or contributor or can_read from tenant

type group
  relations
    define member: [user, service_account, group#member]

type service_account
  relations
    define owner: [user]
```

## PHASE 2 : MIGRATION DES DONN√âES

### Script de Migration

```powershell
# migrate-authorization-data.ps1

param(
    [Parameter(Mandatory=$true)]
    [string]$SourceConnectionString,
    
    [Parameter(Mandatory=$true)]
    [string]$TargetConnectionString,
    
    [switch]$DryRun
)

$ErrorActionPreference = 'Stop'

Write-Host "=== Migration Authorization Data ===" -ForegroundColor Cyan

# 1. Extraire les relations OpenFGA existantes
Write-Host "`n[1/5] Extraction des relations OpenFGA existantes..." -ForegroundColor Yellow

$existingRelations = Invoke-RestMethod `
    -Uri "$env:OPENFGA_API_URL/stores/$env:OPENFGA_STORE_ID/read" `
    -Method POST `
    -Body '{"tuple_key":{}}' `
    -ContentType "application/json"

Write-Host "  ‚Üí $($existingRelations.tuples.Count) relations trouv√©es" -ForegroundColor Gray

# 2. Mapper les utilisateurs vers Principals avec ObjectIds
Write-Host "`n[2/5] Cr√©ation des Principals avec ObjectIds..." -ForegroundColor Yellow

# Dictionnaire pour mapper les anciens IDs (email) vers les nouveaux ObjectIds
$externalIdToObjectId = @{}

$users = $existingRelations.tuples | 
    Where-Object { $_.key.user -match "^user:" } |
    Select-Object -ExpandProperty key |
    Select-Object -ExpandProperty user -Unique

foreach ($user in $users) {
    $externalId = $user -replace "^user:", ""
    $objectId = [guid]::NewGuid().ToString()  # G√©n√®re un nouvel ObjectId
    
    # Stocker le mapping pour la conversion des tuples
    $externalIdToObjectId[$externalId] = $objectId
    
    $principal = @{
        Id = $objectId           # ObjectId (GUID)
        Type = "User"
        ExternalId = $externalId # Email (pour sync IDP)
        DisplayName = $externalId
        CreatedAt = (Get-Date).ToUniversalTime().ToString("o")
    }
    
    if (-not $DryRun) {
        # INSERT INTO authorization.principals (id, type, external_id, display_name, created_at)
        # VALUES ($objectId, 'user', $externalId, $externalId, NOW())
    }
    
    Write-Host "  + Principal: $externalId ‚Üí ObjectId: $objectId" -ForegroundColor Gray
}

# 3. Cr√©er les roles builtin
Write-Host "`n[3/5] Cr√©ation des r√¥les builtin..." -ForegroundColor Yellow

$builtinRoles = @(
    @{ Name = "Platform.Admin"; Description = "Administrateur plateforme"; Level = "platform" },
    @{ Name = "Organization.Owner"; Description = "Propri√©taire organisation"; Level = "organization" },
    @{ Name = "Tenant.Admin"; Description = "Administrateur tenant"; Level = "tenant" },
    @{ Name = "Tenant.Operator"; Description = "Op√©rateur tenant"; Level = "tenant" },
    @{ Name = "Tenant.Contributor"; Description = "Contributeur tenant"; Level = "tenant" },
    @{ Name = "Tenant.Reader"; Description = "Lecteur tenant"; Level = "tenant" },
    @{ Name = "Resource.Admin"; Description = "Administrateur ressource"; Level = "resource" },
    @{ Name = "Resource.Operator"; Description = "Op√©rateur ressource"; Level = "resource" },
    @{ Name = "Resource.User"; Description = "Utilisateur ressource"; Level = "resource" }
)

foreach ($role in $builtinRoles) {
    if (-not $DryRun) {
        # INSERT INTO authorization.role_definitions ...
    }
    Write-Host "  + Role: $($role.Name)" -ForegroundColor Gray
}

# 4. Convertir les tuples en RoleAssignments
Write-Host "`n[4/5] Conversion des relations en assignments..." -ForegroundColor Yellow

$relationToRole = @{
    "admin" = "Tenant.Admin"
    "member" = "Tenant.Contributor"
    "viewer" = "Tenant.Reader"
    "owner" = "Organization.Owner"
}

foreach ($tuple in $existingRelations.tuples) {
    $user = $tuple.key.user
    $relation = $tuple.key.relation
    $objectType = $tuple.key.object -split ":" | Select-Object -First 1
    $scopeId = $tuple.key.object -split ":" | Select-Object -Last 1
    
    $roleName = $relationToRole[$relation]
    if (-not $roleName) { continue }
    
    # R√©cup√©rer l'ObjectId depuis le mapping (au lieu de l'email)
    $externalId = $user -replace "^user:", ""
    $principalObjectId = $externalIdToObjectId[$externalId]
    
    $assignment = @{
        PrincipalId = $principalObjectId  # ObjectId (GUID) du principal
        RoleId = $roleName
        ScopeType = $objectType
        ScopeId = $scopeId
        CreatedAt = (Get-Date).ToUniversalTime().ToString("o")
    }
    
    if (-not $DryRun) {
        # INSERT INTO authorization.role_assignments (principal_id, role_definition_id, scope_type, scope_id, created_at)
        # VALUES ($principalObjectId, $roleId, $objectType, $scopeId, NOW())
    }
    
    Write-Host "  + Assignment: $principalObjectId ‚Üí $roleName on $objectType:$scopeId" -ForegroundColor Gray
}

# 5. Synchroniser avec OpenFGA (nouveau mod√®le avec ObjectIds)
Write-Host "`n[5/5] Synchronisation OpenFGA avec nouveau mod√®le (ObjectIds)..." -ForegroundColor Yellow

if (-not $DryRun) {
    # D√©ployer le nouveau mod√®le
    $newModel = Get-Content "infrastructure/openfga/model-v2.fga" -Raw
    # PUT model...
    
    # Recr√©er les tuples avec le nouveau format utilisant les ObjectIds
    # Ancien: user:john@example.com ‚Üí Nouveau: user:550e8400-e29b-41d4-a716-446655440000
    foreach ($entry in $externalIdToObjectId.GetEnumerator()) {
        Write-Host "  Migration: user:$($entry.Key) ‚Üí user:$($entry.Value)" -ForegroundColor Gray
    }
}

Write-Host "`n=== Migration termin√©e ===" -ForegroundColor Green
```

## PHASE 3 : INT√âGRATION ADMIN.API

### Modifications Requises

```csharp
// 1. Ajouter client Authorization.API
// src/Presentation/LLMProxy.Admin.API/Extensions/AuthorizationClientExtensions.cs

public static class AuthorizationClientExtensions
{
    public static IServiceCollection AddAuthorizationClient(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var authzApiUrl = configuration["AuthorizationApi:BaseUrl"];
        
        services.AddHttpClient<IAuthorizationApiClient, AuthorizationApiClient>(client =>
        {
            client.BaseAddress = new Uri(authzApiUrl);
            client.DefaultRequestHeaders.Accept.Add(
                new MediaTypeWithQualityHeaderValue("application/json"));
        })
        .AddPolicyHandler(GetRetryPolicy())
        .AddPolicyHandler(GetCircuitBreakerPolicy());
        
        return services;
    }
}

// 2. Remplacer OpenFgaAuthorizationService par AuthorizationApiClient
// dans les controllers

[Authorize]
[ApiController]
[Route("api/v1/providers")]
public class ProvidersController : ControllerBase
{
    private readonly IAuthorizationApiClient _authz;
    
    [HttpPost]
    public async Task<IActionResult> Create(
        [FromBody] CreateProviderRequest request)
    {
        var principalId = $"user:{User.Identity.Name}";
        var scope = new Scope("tenant", request.TenantId);
        
        // V√©rification via Authorization.API
        var allowed = await _authz.CheckAsync(new CheckRequest
        {
            PrincipalId = principalId,
            Action = "write",
            ResourceType = "provider",
            Scope = scope
        });
        
        if (!allowed)
            return Forbid();
            
        // ... cr√©er le provider
    }
}
```

### Nouveaux Handlers MediatR

```csharp
// D√©corateur pour v√©rification automatique des permissions
public class AuthorizationBehavior<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IAuthorizedRequest
{
    private readonly IAuthorizationApiClient _authz;
    private readonly ICurrentUserService _currentUser;
    
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var principalId = _currentUser.GetPrincipalId();
        
        var allowed = await _authz.CheckAsync(new CheckRequest
        {
            PrincipalId = principalId,
            Action = request.RequiredAction,
            ResourceType = request.ResourceType,
            Scope = request.GetScope()
        }, cancellationToken);
        
        if (!allowed)
            throw new ForbiddenException(
                $"Access denied for {request.RequiredAction} on {request.ResourceType}");
        
        return await next();
    }
}

// Interface pour les requ√™tes n√©cessitant autorisation
public interface IAuthorizedRequest
{
    string RequiredAction { get; }
    string ResourceType { get; }
    Scope GetScope();
}
```

## PHASE 4 : INT√âGRATION GATEWAY

### Middleware d'Autorisation

```csharp
// src/Presentation/LLMProxy.Gateway/Middleware/AuthorizationMiddleware.cs

public class GatewayAuthorizationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IAuthorizationApiClient _authz;
    private readonly ILogger<GatewayAuthorizationMiddleware> _logger;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var routeId = context.GetRouteId();
        var tenantId = context.GetTenantId();
        var principalId = GetPrincipalId(context);
        
        // V√©rifier permission "use" sur la route
        var checkResult = await _authz.CheckAsync(new CheckRequest
        {
            PrincipalId = principalId,
            Action = "use",
            ResourceType = "route",
            Scope = new Scope("resource", routeId, tenantId)
        });
        
        if (!checkResult.Allowed)
        {
            _logger.LogWarning(
                "Access denied for {PrincipalId} on route {RouteId}: {Reason}",
                principalId, routeId, checkResult.Reason);
                
            context.Response.StatusCode = 403;
            await context.Response.WriteAsJsonAsync(new
            {
                error = "Forbidden",
                message = "You don't have permission to access this route",
                code = "AUTHZ_DENIED"
            });
            return;
        }
        
        // Logger les d√©tails d'autorisation pour audit
        context.Items["AuthorizationResult"] = checkResult;
        
        await _next(context);
    }
}
```

### Service Account pour Gateway

```csharp
// Configuration du service account Gateway
{
    "Gateway": {
        "ServiceAccount": {
            "Id": "sa:llmproxy-gateway",
            "Secret": "${GATEWAY_SERVICE_ACCOUNT_SECRET}",
            "Roles": ["Platform.ServiceGateway"]
        }
    }
}
```

## PHASE 5 : TESTS D'INT√âGRATION

### Tests End-to-End

```csharp
[Collection("Authorization Integration")]
public class AuthorizationIntegrationTests : IAsyncLifetime
{
    private readonly AuthorizationApiFactory _factory;
    private readonly HttpClient _client;
    
    [Fact]
    public async Task AssignRole_ShouldEnableAccess()
    {
        // Arrange
        var principal = "user:test@example.com";
        var scope = new Scope("tenant", "tenant-123");
        
        // V√©rifier pas d'acc√®s initial
        var checkBefore = await _client.PostAsJsonAsync("/api/v1/check", new
        {
            PrincipalId = principal,
            Action = "read",
            ResourceType = "provider",
            Scope = scope
        });
        var resultBefore = await checkBefore.Content.ReadFromJsonAsync<CheckResponse>();
        resultBefore.Allowed.Should().BeFalse();
        
        // Act - Assigner le r√¥le
        await _client.PostAsJsonAsync("/api/v1/assignments", new
        {
            PrincipalId = principal,
            RoleId = "Tenant.Reader",
            Scope = scope
        });
        
        // Assert - V√©rifier acc√®s
        var checkAfter = await _client.PostAsJsonAsync("/api/v1/check", new
        {
            PrincipalId = principal,
            Action = "read",
            ResourceType = "provider",
            Scope = scope
        });
        var resultAfter = await checkAfter.Content.ReadFromJsonAsync<CheckResponse>();
        resultAfter.Allowed.Should().BeTrue();
    }
    
    [Fact]
    public async Task ScopeInheritance_ShouldGrantAccessToChildResources()
    {
        // Arrange
        var principal = "user:admin@example.com";
        var orgScope = new Scope("organization", "org-456");
        var tenantScope = new Scope("tenant", "tenant-123", organizationId: "org-456");
        
        // Assigner Organization.Owner sur l'org
        await _client.PostAsJsonAsync("/api/v1/assignments", new
        {
            PrincipalId = principal,
            RoleId = "Organization.Owner",
            Scope = orgScope
        });
        
        // Act - V√©rifier acc√®s sur tenant enfant
        var check = await _client.PostAsJsonAsync("/api/v1/check", new
        {
            PrincipalId = principal,
            Action = "admin",
            ResourceType = "tenant",
            Scope = tenantScope
        });
        
        // Assert - L'h√©ritage doit fonctionner
        var result = await check.Content.ReadFromJsonAsync<CheckResponse>();
        result.Allowed.Should().BeTrue();
        result.Reason.Should().Contain("inherited from organization");
    }
    
    [Fact]
    public async Task GroupMembership_ShouldGrantGroupPermissions()
    {
        // Arrange
        var user = "user:member@example.com";
        var group = "group:admins";
        var scope = new Scope("tenant", "tenant-123");
        
        // Cr√©er groupe et ajouter utilisateur
        await _client.PostAsJsonAsync("/api/v1/groups", new
        {
            Name = "admins",
            DisplayName = "Administrators"
        });
        await _client.PostAsJsonAsync("/api/v1/groups/admins/members", new
        {
            PrincipalId = user
        });
        
        // Assigner r√¥le au groupe
        await _client.PostAsJsonAsync("/api/v1/assignments", new
        {
            PrincipalId = group,
            RoleId = "Tenant.Admin",
            Scope = scope
        });
        
        // Act - V√©rifier acc√®s via groupe
        var check = await _client.PostAsJsonAsync("/api/v1/check", new
        {
            PrincipalId = user,
            Action = "admin",
            ResourceType = "tenant",
            Scope = scope
        });
        
        // Assert
        var result = await check.Content.ReadFromJsonAsync<CheckResponse>();
        result.Allowed.Should().BeTrue();
        result.Reason.Should().Contain("via group 'admins'");
    }
}
```

## PHASE 6 : DOCUMENTATION

### Documentation API (README)

```markdown
# LLMProxy Authorization API

## Concepts

### Scopes
- `platform:/` - Niveau plateforme (global)
- `organization:/{orgId}` - Niveau organisation
- `tenant:/{orgId}/{tenantId}` - Niveau tenant
- `resource:/{orgId}/{tenantId}/{resourceType}/{resourceId}` - Niveau ressource

### Principals
- `user:{email}` - Utilisateur
- `group:{name}` - Groupe
- `sa:{name}` - Service Account

### R√¥les Builtin
| R√¥le | Scope | Permissions |
|------|-------|-------------|
| Platform.Admin | platform | Toutes |
| Organization.Owner | organization | Toutes sur org + tenants |
| Tenant.Admin | tenant | Toutes sur tenant |
| Tenant.Operator | tenant | Configure providers, routes |
| Tenant.Contributor | tenant | Modifie routes, prompts |
| Tenant.Reader | tenant | Lecture seule |
| Resource.Admin | resource | Toutes sur ressource |
| Resource.Operator | resource | Configure ressource |
| Resource.User | resource | Utilise ressource |
```

## CRIT√àRES DE SUCC√àS

- [ ] Migration des donn√©es existantes sans perte
- [ ] Nouveau mod√®le OpenFGA d√©ploy√©
- [ ] Admin.API int√©gr√© avec Authorization.API
- [ ] Gateway int√©gr√© avec Authorization.API
- [ ] Tests E2E passent √† 100%
- [ ] Documentation compl√®te
- [ ] Rollback possible si n√©cessaire

## ESTIMATION

**Effort** : 10h
**Complexit√©** : Tr√®s Haute (migration + int√©gration)

## D√âPENDANCES

- 067.4 compl√©t√©e

## RISQUES

1. **Perte de donn√©es** : Mitigation via dry-run et backup
2. **R√©gression permissions** : Tests avant/apr√®s + rollback
3. **Downtime** : Migration en blue-green si possible

## TRACKING
