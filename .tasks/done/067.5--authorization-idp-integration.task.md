# TÃ¢che 067.5 - IDP Integration Layer (JIT + Batch + Webhook)

## PRIORITÃ‰
ğŸŸ¡ **P3 - MOYENNE** (DÃ©pend de 067.2 et 067.3)

## OBJECTIF

ImplÃ©menter les 3 stratÃ©gies de synchronisation avec les Identity Providers externes :
- **JIT (Just-In-Time)** : Sync au premier accÃ¨s via JWT claims
- **Batch** : Synchronisation pÃ©riodique (cron toutes les 15 min)
- **Webhook** : Notification temps rÃ©el depuis l'IDP

Providers supportÃ©s :
- Azure AD (Microsoft Entra ID)
- Okta
- Keycloak

## DÃ‰PENDANCES

- âœ… **067.2** - Infrastructure Layer (OpenFGA, Redis, Audit)
- âœ… **067.3** - Application Layer (GroupService)

## DÃ‰CISIONS DE CADRAGE APPLIQUÃ‰ES

| DÃ©cision | Impact |
|----------|--------|
| 3 stratÃ©gies sync | JIT + Batch + Webhook Ã  implÃ©menter |
| RÃ©vocation immÃ©diate | Retrait groupe = perte permissions instantanÃ©e |
| IDP = source identitÃ©s | Pas de crÃ©ation de principals locale |

## PRINCIPES

### L'IDP est la Source de VÃ©ritÃ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Azure AD     â”‚      â”‚                    â”‚
â”‚    Okta         â”‚â”€â”€â”€â”€â”€â–¶â”‚  Authorization     â”‚
â”‚    Keycloak     â”‚ sync â”‚  Application       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚ OpenFGA  â”‚
                         â”‚ (tuples) â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **L'application ne crÃ©e JAMAIS de principals**
- Elle synchronise les group memberships depuis l'IDP
- La rÃ©vocation est **immÃ©diate** via mise Ã  jour tuples OpenFGA

### 3 StratÃ©gies de Synchronisation

| StratÃ©gie | DÃ©clencheur | Latence | ImplÃ©mentation |
|-----------|-------------|---------|----------------|
| **JIT** | Premier accÃ¨s utilisateur | Temps rÃ©el | Middleware JWT |
| **Batch** | Cron job (toutes les 15 min) | 0-15 min | Background Service |
| **Webhook** | Ã‰vÃ©nement IDP | Temps rÃ©el | Endpoint HTTP |

## STRUCTURE DE FICHIERS

```
authorization/src/Authorization.Infrastructure/
â”œâ”€â”€ Idp/
â”‚   â”œâ”€â”€ IIdpClient.cs
â”‚   â”œâ”€â”€ IdpClientFactory.cs
â”‚   â”œâ”€â”€ AzureAd/
â”‚   â”‚   â”œâ”€â”€ AzureAdClient.cs
â”‚   â”‚   â”œâ”€â”€ AzureAdConfiguration.cs
â”‚   â”‚   â”œâ”€â”€ GraphApiClient.cs
â”‚   â”‚   â””â”€â”€ Models/
â”‚   â”‚       â”œâ”€â”€ AzureAdUser.cs
â”‚   â”‚       â””â”€â”€ AzureAdGroup.cs
â”‚   â”œâ”€â”€ Okta/
â”‚   â”‚   â”œâ”€â”€ OktaClient.cs
â”‚   â”‚   â”œâ”€â”€ OktaConfiguration.cs
â”‚   â”‚   â””â”€â”€ Models/
â”‚   â”‚       â”œâ”€â”€ OktaUser.cs
â”‚   â”‚       â””â”€â”€ OktaGroup.cs
â”‚   â”œâ”€â”€ Keycloak/
â”‚   â”‚   â”œâ”€â”€ KeycloakClient.cs
â”‚   â”‚   â”œâ”€â”€ KeycloakConfiguration.cs
â”‚   â”‚   â””â”€â”€ Models/
â”‚   â”‚       â”œâ”€â”€ KeycloakUser.cs
â”‚   â”‚       â””â”€â”€ KeycloakGroup.cs
â”‚   â””â”€â”€ Sync/
â”‚       â”œâ”€â”€ IdpSyncService.cs
â”‚       â”œâ”€â”€ IdpSyncJob.cs
â”‚       â””â”€â”€ JitSyncMiddleware.cs
```

## IMPLÃ‰MENTATION

### Interface IIdpClient

```csharp
/// <summary>
/// Client abstrait pour interagir avec un Identity Provider.
/// </summary>
public interface IIdpClient
{
    /// <summary>
    /// Identifiant de l'IDP (azure-ad, okta, keycloak).
    /// </summary>
    string IdpSource { get; }
    
    /// <summary>
    /// RÃ©cupÃ¨re un utilisateur par son ObjectId.
    /// </summary>
    Task<IdpUser?> GetUserByIdAsync(Guid objectId, CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©cupÃ¨re un utilisateur par son identifiant externe (email, UPN).
    /// </summary>
    Task<IdpUser?> GetUserByExternalIdAsync(string externalId, CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©cupÃ¨re un groupe par son ObjectId.
    /// </summary>
    Task<IdpGroup?> GetGroupByIdAsync(Guid objectId, CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©cupÃ¨re les membres d'un groupe.
    /// </summary>
    Task<IReadOnlyList<IdpPrincipal>> GetGroupMembersAsync(Guid groupId, CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©cupÃ¨re les groupes d'un utilisateur.
    /// </summary>
    Task<IReadOnlyList<IdpGroup>> GetUserGroupsAsync(Guid userId, CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©cupÃ¨re un service account par son client_id.
    /// </summary>
    Task<IdpServiceAccount?> GetServiceAccountAsync(string clientId, CancellationToken ct = default);
    
    /// <summary>
    /// Liste tous les utilisateurs (pour batch sync).
    /// </summary>
    IAsyncEnumerable<IdpUser> ListUsersAsync(CancellationToken ct = default);
    
    /// <summary>
    /// Liste tous les groupes (pour batch sync).
    /// </summary>
    IAsyncEnumerable<IdpGroup> ListGroupsAsync(CancellationToken ct = default);
}

// DTOs IDP
public record IdpPrincipal(
    Guid ObjectId,
    string Type,        // User, Group, ServiceAccount
    string ExternalId,
    string DisplayName);

public record IdpUser(
    Guid ObjectId,
    string Email,
    string DisplayName,
    string? UserPrincipalName,
    bool IsEnabled) : IdpPrincipal(ObjectId, "User", Email, DisplayName);

public record IdpGroup(
    Guid ObjectId,
    string Name,
    string? Description) : IdpPrincipal(ObjectId, "Group", Name, Name);

public record IdpServiceAccount(
    Guid ObjectId,
    string ClientId,
    string DisplayName) : IdpPrincipal(ObjectId, "ServiceAccount", ClientId, DisplayName);
```

### Azure AD Client (Microsoft Graph)

```csharp
public class AzureAdClient : IIdpClient
{
    private readonly GraphServiceClient _graph;
    private readonly ILogger<AzureAdClient> _logger;
    
    public string IdpSource => "azure-ad";
    
    public AzureAdClient(
        AzureAdConfiguration config,
        ILogger<AzureAdClient> logger)
    {
        _logger = logger;
        
        var credential = new ClientSecretCredential(
            config.TenantId,
            config.ClientId,
            config.ClientSecret);
        
        _graph = new GraphServiceClient(credential);
    }
    
    public async Task<IdpUser?> GetUserByIdAsync(Guid objectId, CancellationToken ct = default)
    {
        try
        {
            var user = await _graph.Users[objectId.ToString()]
                .GetAsync(r => r.QueryParameters.Select = new[] 
                    { "id", "mail", "displayName", "userPrincipalName", "accountEnabled" }, 
                    ct);
            
            if (user == null) return null;
            
            return new IdpUser(
                Guid.Parse(user.Id!),
                user.Mail ?? user.UserPrincipalName!,
                user.DisplayName!,
                user.UserPrincipalName,
                user.AccountEnabled ?? false);
        }
        catch (ServiceException ex) when (ex.ResponseStatusCode == 404)
        {
            return null;
        }
    }
    
    public async Task<IReadOnlyList<IdpGroup>> GetUserGroupsAsync(Guid userId, CancellationToken ct = default)
    {
        var groups = new List<IdpGroup>();
        
        var memberOf = await _graph.Users[userId.ToString()]
            .MemberOf
            .GetAsync(ct);
        
        foreach (var item in memberOf?.Value ?? Enumerable.Empty<DirectoryObject>())
        {
            if (item is Group group)
            {
                groups.Add(new IdpGroup(
                    Guid.Parse(group.Id!),
                    group.DisplayName!,
                    group.Description));
            }
        }
        
        return groups;
    }
    
    public async Task<IReadOnlyList<IdpPrincipal>> GetGroupMembersAsync(Guid groupId, CancellationToken ct = default)
    {
        var members = new List<IdpPrincipal>();
        
        var result = await _graph.Groups[groupId.ToString()]
            .Members
            .GetAsync(ct);
        
        foreach (var item in result?.Value ?? Enumerable.Empty<DirectoryObject>())
        {
            if (item is User user)
            {
                members.Add(new IdpUser(
                    Guid.Parse(user.Id!),
                    user.Mail ?? user.UserPrincipalName!,
                    user.DisplayName!,
                    user.UserPrincipalName,
                    user.AccountEnabled ?? false));
            }
            else if (item is Group group)
            {
                members.Add(new IdpGroup(
                    Guid.Parse(group.Id!),
                    group.DisplayName!,
                    group.Description));
            }
        }
        
        return members;
    }
    
    public async IAsyncEnumerable<IdpUser> ListUsersAsync([EnumeratorCancellation] CancellationToken ct = default)
    {
        var response = await _graph.Users
            .GetAsync(r =>
            {
                r.QueryParameters.Select = new[] 
                    { "id", "mail", "displayName", "userPrincipalName", "accountEnabled" };
                r.QueryParameters.Top = 100;
            }, ct);
        
        var pageIterator = PageIterator<User, UserCollectionResponse>
            .CreatePageIterator(
                _graph, 
                response!, 
                user =>
                {
                    return true; // Continue iteration
                });
        
        await foreach (var user in IterateUsersAsync(response, ct))
        {
            yield return new IdpUser(
                Guid.Parse(user.Id!),
                user.Mail ?? user.UserPrincipalName!,
                user.DisplayName!,
                user.UserPrincipalName,
                user.AccountEnabled ?? false);
        }
    }
    
    private async IAsyncEnumerable<User> IterateUsersAsync(
        UserCollectionResponse? response, 
        [EnumeratorCancellation] CancellationToken ct)
    {
        while (response != null)
        {
            foreach (var user in response.Value ?? Enumerable.Empty<User>())
            {
                ct.ThrowIfCancellationRequested();
                yield return user;
            }
            
            if (response.OdataNextLink == null) break;
            
            response = await _graph.Users
                .WithUrl(response.OdataNextLink)
                .GetAsync(ct);
        }
    }
    
    // ... autres mÃ©thodes
}

public class AzureAdConfiguration
{
    public string TenantId { get; set; } = string.Empty;
    public string ClientId { get; set; } = string.Empty;
    public string ClientSecret { get; set; } = string.Empty;
}
```

### Okta Client

```csharp
public class OktaClient : IIdpClient
{
    private readonly IOktaClient _okta;
    private readonly ILogger<OktaClient> _logger;
    
    public string IdpSource => "okta";
    
    public OktaClient(OktaConfiguration config, ILogger<OktaClient> logger)
    {
        _logger = logger;
        _okta = new OktaClient(new OktaClientConfiguration
        {
            OktaDomain = config.Domain,
            Token = config.ApiToken
        });
    }
    
    public async Task<IdpUser?> GetUserByIdAsync(Guid objectId, CancellationToken ct = default)
    {
        try
        {
            var user = await _okta.Users.GetUserAsync(objectId.ToString(), ct);
            if (user == null) return null;
            
            return new IdpUser(
                Guid.Parse(user.Id),
                user.Profile.Email,
                $"{user.Profile.FirstName} {user.Profile.LastName}",
                user.Profile.Login,
                user.Status == UserStatus.Active);
        }
        catch (OktaApiException ex) when (ex.StatusCode == 404)
        {
            return null;
        }
    }
    
    public async Task<IReadOnlyList<IdpGroup>> GetUserGroupsAsync(Guid userId, CancellationToken ct = default)
    {
        var groups = new List<IdpGroup>();
        
        await foreach (var group in _okta.Users.ListUserGroups(userId.ToString()).ToAsyncEnumerable())
        {
            ct.ThrowIfCancellationRequested();
            
            groups.Add(new IdpGroup(
                Guid.Parse(group.Id),
                group.Profile.Name,
                group.Profile.Description));
        }
        
        return groups;
    }
    
    // ... autres mÃ©thodes
}

public class OktaConfiguration
{
    public string Domain { get; set; } = string.Empty;
    public string ApiToken { get; set; } = string.Empty;
}
```

### IdpSyncService

```csharp
/// <summary>
/// Service de synchronisation des principals depuis les IDPs.
/// </summary>
public class IdpSyncService : IIdpSyncService
{
    private readonly IEnumerable<IIdpClient> _idpClients;
    private readonly IMediator _mediator;
    private readonly IPrincipalRepository _principalRepo;
    private readonly ILogger<IdpSyncService> _logger;
    
    public IdpSyncService(
        IEnumerable<IIdpClient> idpClients,
        IMediator mediator,
        IPrincipalRepository principalRepo,
        ILogger<IdpSyncService> logger)
    {
        _idpClients = idpClients;
        _mediator = mediator;
        _principalRepo = principalRepo;
        _logger = logger;
    }
    
    /// <summary>
    /// Synchronise un principal depuis les claims JWT (JIT sync).
    /// </summary>
    public async Task<SyncPrincipalResult> SyncFromJwtClaimsAsync(
        ClaimsPrincipal claims,
        string idpSource,
        CancellationToken ct = default)
    {
        var objectId = Guid.Parse(
            claims.FindFirstValue("oid") 
            ?? claims.FindFirstValue("sub")
            ?? throw new ArgumentException("No object ID in claims"));
        
        var type = DetermineTypeFromClaims(claims);
        var externalId = claims.FindFirstValue("preferred_username")
            ?? claims.FindFirstValue("email")
            ?? claims.FindFirstValue("azp") // Service account
            ?? objectId.ToString();
        
        var displayName = claims.FindFirstValue("name") ?? externalId;
        var email = claims.FindFirstValue("email");
        
        var command = new SyncPrincipalCommand(
            objectId,
            type,
            externalId,
            displayName,
            email,
            idpSource);
        
        var result = await _mediator.Send(command, ct);
        
        // Sync les groupes si disponibles dans les claims
        await SyncGroupsFromClaimsAsync(objectId, claims, idpSource, ct);
        
        return result;
    }
    
    /// <summary>
    /// Synchronise un utilisateur par son ObjectId depuis l'IDP.
    /// </summary>
    public async Task<SyncPrincipalResult> SyncUserByIdAsync(
        Guid objectId,
        string idpSource,
        CancellationToken ct = default)
    {
        var client = GetClient(idpSource);
        var user = await client.GetUserByIdAsync(objectId, ct);
        
        if (user == null)
        {
            _logger.LogWarning("User {ObjectId} not found in {IdpSource}", objectId, idpSource);
            return new SyncPrincipalResult(false, false, "User not found in IDP");
        }
        
        var command = new SyncPrincipalCommand(
            user.ObjectId,
            "User",
            user.ExternalId,
            user.DisplayName,
            user.Email,
            idpSource);
        
        var result = await _mediator.Send(command, ct);
        
        // Sync les groupes
        await SyncUserGroupsAsync(objectId, idpSource, ct);
        
        return result;
    }
    
    /// <summary>
    /// Synchronise les groupes d'un utilisateur.
    /// </summary>
    public async Task SyncUserGroupsAsync(
        Guid userId,
        string idpSource,
        CancellationToken ct = default)
    {
        var client = GetClient(idpSource);
        var groups = await client.GetUserGroupsAsync(userId, ct);
        
        foreach (var group in groups)
        {
            // Sync le groupe
            await _mediator.Send(new SyncPrincipalCommand(
                group.ObjectId,
                "Group",
                group.ExternalId,
                group.DisplayName,
                null,
                idpSource), ct);
            
            // Sync la relation
            await _mediator.Send(new SyncGroupMembershipCommand(
                group.ObjectId,
                userId,
                idpSource), ct);
        }
    }
    
    /// <summary>
    /// Synchronisation batch de tous les utilisateurs et groupes.
    /// </summary>
    public async Task BatchSyncAsync(string idpSource, CancellationToken ct = default)
    {
        var client = GetClient(idpSource);
        var syncedCount = 0;
        
        _logger.LogInformation("Starting batch sync for {IdpSource}", idpSource);
        
        // Sync tous les utilisateurs
        await foreach (var user in client.ListUsersAsync(ct))
        {
            await _mediator.Send(new SyncPrincipalCommand(
                user.ObjectId,
                "User",
                user.ExternalId,
                user.DisplayName,
                user.Email,
                idpSource), ct);
            
            syncedCount++;
            
            if (syncedCount % 100 == 0)
            {
                _logger.LogInformation("Synced {Count} users from {IdpSource}", syncedCount, idpSource);
            }
        }
        
        // Sync tous les groupes
        await foreach (var group in client.ListGroupsAsync(ct))
        {
            await _mediator.Send(new SyncPrincipalCommand(
                group.ObjectId,
                "Group",
                group.ExternalId,
                group.DisplayName,
                null,
                idpSource), ct);
            
            // Sync les membres du groupe
            var members = await client.GetGroupMembersAsync(group.ObjectId, ct);
            foreach (var member in members)
            {
                await _mediator.Send(new SyncGroupMembershipCommand(
                    group.ObjectId,
                    member.ObjectId,
                    idpSource), ct);
            }
        }
        
        _logger.LogInformation("Batch sync completed for {IdpSource}: {Count} principals", idpSource, syncedCount);
    }
    
    private IIdpClient GetClient(string idpSource)
    {
        return _idpClients.FirstOrDefault(c => c.IdpSource == idpSource)
            ?? throw new ArgumentException($"Unknown IDP source: {idpSource}");
    }
    
    private static string DetermineTypeFromClaims(ClaimsPrincipal claims)
    {
        // Azure AD: "idtyp" claim
        var idtyp = claims.FindFirstValue("idtyp");
        if (idtyp == "app") return "ServiceAccount";
        
        // VÃ©rifier si c'est un service principal (pas d'email personnel)
        if (claims.FindFirstValue("email") == null && 
            claims.FindFirstValue("preferred_username") == null)
        {
            return "ServiceAccount";
        }
        
        return "User";
    }
    
    private async Task SyncGroupsFromClaimsAsync(
        Guid userId,
        ClaimsPrincipal claims,
        string idpSource,
        CancellationToken ct)
    {
        // Azure AD: "groups" claim (si configurÃ©)
        var groupClaims = claims.FindAll("groups");
        
        foreach (var groupClaim in groupClaims)
        {
            if (Guid.TryParse(groupClaim.Value, out var groupId))
            {
                await _mediator.Send(new SyncGroupMembershipCommand(
                    groupId,
                    userId,
                    idpSource), ct);
            }
        }
    }
}
```

### JIT Sync Middleware

```csharp
/// <summary>
/// Middleware qui synchronise automatiquement le principal lors de la premiÃ¨re requÃªte.
/// </summary>
public class JitSyncMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<JitSyncMiddleware> _logger;
    
    public JitSyncMiddleware(RequestDelegate next, ILogger<JitSyncMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(
        HttpContext context,
        IIdpSyncService syncService,
        IPrincipalRepository principalRepo)
    {
        if (context.User.Identity?.IsAuthenticated == true)
        {
            var objectIdClaim = context.User.FindFirstValue("oid") 
                ?? context.User.FindFirstValue("sub");
            
            if (Guid.TryParse(objectIdClaim, out var objectId))
            {
                // VÃ©rifier si le principal existe dÃ©jÃ 
                var principalId = PrincipalId.From(objectId);
                var existing = await principalRepo.GetByIdAsync(principalId);
                
                if (existing == null || ShouldRefresh(existing))
                {
                    // DÃ©terminer l'IDP source depuis l'issuer
                    var issuer = context.User.FindFirstValue("iss") ?? "";
                    var idpSource = DetermineIdpSource(issuer);
                    
                    _logger.LogDebug(
                        "JIT sync for principal {ObjectId} from {IdpSource}",
                        objectId, idpSource);
                    
                    await syncService.SyncFromJwtClaimsAsync(
                        context.User,
                        idpSource,
                        context.RequestAborted);
                }
            }
        }
        
        await _next(context);
    }
    
    private static bool ShouldRefresh(Principal principal)
    {
        // RafraÃ®chir si sync > 1 heure
        return principal.SyncedAt < DateTime.UtcNow.AddHours(-1);
    }
    
    private static string DetermineIdpSource(string issuer)
    {
        if (issuer.Contains("microsoftonline.com") || issuer.Contains("sts.windows.net"))
            return "azure-ad";
        if (issuer.Contains("okta.com") || issuer.Contains("oktapreview.com"))
            return "okta";
        if (issuer.Contains("keycloak"))
            return "keycloak";
        
        return "unknown";
    }
}
```

### Dependency Injection

```csharp
public static class IdpServiceCollectionExtensions
{
    public static IServiceCollection AddIdpIntegration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Azure AD
        var azureConfig = configuration.GetSection("Idp:AzureAd").Get<AzureAdConfiguration>();
        if (azureConfig != null && !string.IsNullOrEmpty(azureConfig.TenantId))
        {
            services.AddSingleton(azureConfig);
            services.AddSingleton<IIdpClient, AzureAdClient>();
        }
        
        // Okta
        var oktaConfig = configuration.GetSection("Idp:Okta").Get<OktaConfiguration>();
        if (oktaConfig != null && !string.IsNullOrEmpty(oktaConfig.Domain))
        {
            services.AddSingleton(oktaConfig);
            services.AddSingleton<IIdpClient, OktaClient>();
        }
        
        // Keycloak
        var keycloakConfig = configuration.GetSection("Idp:Keycloak").Get<KeycloakConfiguration>();
        if (keycloakConfig != null && !string.IsNullOrEmpty(keycloakConfig.BaseUrl))
        {
            services.AddSingleton(keycloakConfig);
            services.AddSingleton<IIdpClient, KeycloakClient>();
        }
        
        // Sync service
        services.AddScoped<IIdpSyncService, IdpSyncService>();
        
        return services;
    }
}
```

## CRITÃˆRES DE SUCCÃˆS

- [ ] Interface IIdpClient dÃ©finie
- [ ] Azure AD Client avec Microsoft Graph
- [ ] Okta Client avec SDK Okta
- [ ] Keycloak Client avec API Admin
- [ ] IdpSyncService avec JIT et Batch sync
- [ ] JitSyncMiddleware fonctionnel
- [ ] Tests unitaires avec mocks
- [ ] Tests d'intÃ©gration avec IDP de test
- [ ] Build : 0 erreurs, 0 warnings

## ESTIMATION

**Effort** : 6h
**ComplexitÃ©** : Moyenne-Haute

## TRACKING
