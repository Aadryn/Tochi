# TÃ¢che 067.6 - Backend LLMProxy Integration

## PRIORITÃ‰
ğŸŸ¡ **P3 - MOYENNE** (DÃ©pend de 067.4)

## OBJECTIF

IntÃ©grer l'application Authorization autonome avec le backend LLMProxy existant :
- Client SDK pour appeler l'API Authorization
- Middleware d'autorisation pour les controllers
- Configuration et connection string

## DÃ‰PENDANCES

- âœ… **067.4** - Authorization API Layer (endpoints disponibles)

## ARCHITECTURE D'INTÃ‰GRATION

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LLMProxy Backend                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Gateway / Admin API                    â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ Controllers    â”‚â”€â”€â”€â–¶â”‚ IAuthorizationService        â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                              â”‚                            â”‚   â”‚
â”‚  â”‚                              â”‚ HTTP                       â”‚   â”‚
â”‚  â”‚                              â–¼                            â”‚   â”‚
â”‚  â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚   â”‚
â”‚  â”‚                    â”‚ Authorization    â”‚                   â”‚   â”‚
â”‚  â”‚                    â”‚ Client SDK       â”‚                   â”‚   â”‚
â”‚  â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚ HTTP/REST
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Authorization Application                        â”‚
â”‚                      (Port 5100)                                 â”‚
â”‚  /api/v1/permissions/check                                      â”‚
â”‚  /api/v1/assignments                                            â”‚
â”‚  /api/v1/principals/sync                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## STRUCTURE DE FICHIERS

```
backend/src/Infrastructure/
â””â”€â”€ LLMProxy.Infrastructure.Authorization/
    â”œâ”€â”€ LLMProxy.Infrastructure.Authorization.csproj
    â”œâ”€â”€ DependencyInjection.cs
    â”œâ”€â”€ Configuration/
    â”‚   â””â”€â”€ AuthorizationClientOptions.cs
    â”œâ”€â”€ Services/
    â”‚   â”œâ”€â”€ IAuthorizationService.cs
    â”‚   â”œâ”€â”€ AuthorizationService.cs
    â”‚   â””â”€â”€ CachedAuthorizationService.cs
    â”œâ”€â”€ Middleware/
    â”‚   â”œâ”€â”€ AuthorizationMiddleware.cs
    â”‚   â””â”€â”€ ScopeResolutionMiddleware.cs
    â”œâ”€â”€ Attributes/
    â”‚   â”œâ”€â”€ RequirePermissionAttribute.cs
    â”‚   â””â”€â”€ RequireScopeAttribute.cs
    â””â”€â”€ Handlers/
        â””â”€â”€ PermissionAuthorizationHandler.cs
```

## IMPLÃ‰MENTATION

### IAuthorizationService

```csharp
/// <summary>
/// Service client pour l'application Authorization externe.
/// </summary>
public interface IAuthorizationService
{
    /// <summary>
    /// VÃ©rifie si le principal courant a une permission spÃ©cifique.
    /// </summary>
    Task<bool> CheckPermissionAsync(
        Guid principalId,
        string action,
        string resourceType,
        string scope,
        CancellationToken ct = default);
    
    /// <summary>
    /// VÃ©rifie avec dÃ©tails (rÃ´le, scope d'origine).
    /// </summary>
    Task<PermissionCheckResult> CheckPermissionDetailedAsync(
        Guid principalId,
        string action,
        string resourceType,
        string scope,
        CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©cupÃ¨re les permissions effectives sur un scope.
    /// </summary>
    Task<EffectivePermissionsResult> GetEffectivePermissionsAsync(
        Guid principalId,
        string scope,
        CancellationToken ct = default);
    
    /// <summary>
    /// Assigne un rÃ´le Ã  un principal.
    /// </summary>
    Task<AssignmentResult> AssignRoleAsync(
        Guid principalId,
        string roleName,
        string scope,
        Guid assignedBy,
        DateTime? expiresAt = null,
        CancellationToken ct = default);
    
    /// <summary>
    /// RÃ©voque un assignment.
    /// </summary>
    Task RevokeAssignmentAsync(
        Guid assignmentId,
        CancellationToken ct = default);
    
    /// <summary>
    /// Synchronise un principal depuis le token JWT.
    /// </summary>
    Task SyncPrincipalAsync(
        ClaimsPrincipal user,
        CancellationToken ct = default);
}

public record PermissionCheckResult(
    bool IsAllowed,
    string? GrantedVia,
    string? Role,
    string? MatchingScope);

public record EffectivePermissionsResult(
    string PrincipalId,
    string Scope,
    IReadOnlyList<EffectiveRoleResult> Roles,
    IReadOnlyList<string> Permissions);

public record EffectiveRoleResult(
    string Name,
    string AssignedScope,
    string GrantedVia);

public record AssignmentResult(
    Guid AssignmentId,
    bool Success,
    string? Error);
```

### AuthorizationService (HTTP Client)

```csharp
public class AuthorizationService : IAuthorizationService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<AuthorizationService> _logger;
    private readonly JsonSerializerOptions _jsonOptions;
    
    public AuthorizationService(
        HttpClient httpClient,
        ILogger<AuthorizationService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        _jsonOptions = new JsonSerializerOptions 
        { 
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase 
        };
    }
    
    public async Task<bool> CheckPermissionAsync(
        Guid principalId,
        string action,
        string resourceType,
        string scope,
        CancellationToken ct = default)
    {
        var result = await CheckPermissionDetailedAsync(principalId, action, resourceType, scope, ct);
        return result.IsAllowed;
    }
    
    public async Task<PermissionCheckResult> CheckPermissionDetailedAsync(
        Guid principalId,
        string action,
        string resourceType,
        string scope,
        CancellationToken ct = default)
    {
        _logger.LogDebug(
            "Checking permission: Principal={PrincipalId}, Action={Action}, Resource={Resource}, Scope={Scope}",
            principalId, action, resourceType, scope);
        
        var request = new
        {
            Action = action,
            ResourceType = resourceType,
            Scope = scope
        };
        
        var response = await _httpClient.PostAsJsonAsync(
            $"api/v1/permissions/check/principal/{principalId}",
            request,
            _jsonOptions,
            ct);
        
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError(
                "Permission check failed: {StatusCode} - {Reason}",
                response.StatusCode, response.ReasonPhrase);
            
            return new PermissionCheckResult(false, null, null, null);
        }
        
        var result = await response.Content.ReadFromJsonAsync<PermissionCheckResponse>(_jsonOptions, ct);
        
        return new PermissionCheckResult(
            result?.IsAllowed ?? false,
            result?.GrantedVia,
            result?.Role,
            result?.MatchingScope);
    }
    
    public async Task<EffectivePermissionsResult> GetEffectivePermissionsAsync(
        Guid principalId,
        string scope,
        CancellationToken ct = default)
    {
        var encodedScope = Uri.EscapeDataString(scope);
        var response = await _httpClient.GetAsync(
            $"api/v1/permissions/effective?scope={encodedScope}",
            ct);
        
        response.EnsureSuccessStatusCode();
        
        var result = await response.Content
            .ReadFromJsonAsync<EffectivePermissionsResponse>(_jsonOptions, ct);
        
        return new EffectivePermissionsResult(
            result!.PrincipalId,
            result.Scope,
            result.Roles.Select(r => new EffectiveRoleResult(r.Name, r.AssignedScope, r.GrantedVia)).ToList(),
            result.Permissions);
    }
    
    public async Task<AssignmentResult> AssignRoleAsync(
        Guid principalId,
        string roleName,
        string scope,
        Guid assignedBy,
        DateTime? expiresAt = null,
        CancellationToken ct = default)
    {
        var request = new
        {
            PrincipalId = principalId,
            RoleName = roleName,
            Scope = scope,
            ExpiresAt = expiresAt
        };
        
        var response = await _httpClient.PostAsJsonAsync(
            "api/v1/assignments",
            request,
            _jsonOptions,
            ct);
        
        if (!response.IsSuccessStatusCode)
        {
            var error = await response.Content.ReadAsStringAsync(ct);
            return new AssignmentResult(Guid.Empty, false, error);
        }
        
        var result = await response.Content.ReadFromJsonAsync<AssignmentResponse>(_jsonOptions, ct);
        return new AssignmentResult(result!.Id, true, null);
    }
    
    public async Task RevokeAssignmentAsync(Guid assignmentId, CancellationToken ct = default)
    {
        var response = await _httpClient.DeleteAsync(
            $"api/v1/assignments/{assignmentId}",
            ct);
        
        response.EnsureSuccessStatusCode();
    }
    
    public async Task SyncPrincipalAsync(ClaimsPrincipal user, CancellationToken ct = default)
    {
        var objectId = Guid.Parse(
            user.FindFirstValue("oid") ?? user.FindFirstValue("sub")!);
        
        var issuer = user.FindFirstValue("iss") ?? "";
        var idpSource = DetermineIdpSource(issuer);
        
        var request = new
        {
            ObjectId = objectId,
            Type = DetermineType(user),
            ExternalId = user.FindFirstValue("preferred_username") ?? user.FindFirstValue("email") ?? objectId.ToString(),
            DisplayName = user.FindFirstValue("name") ?? "Unknown",
            Email = user.FindFirstValue("email"),
            IdpSource = idpSource
        };
        
        var response = await _httpClient.PostAsJsonAsync(
            "api/v1/principals/sync",
            request,
            _jsonOptions,
            ct);
        
        response.EnsureSuccessStatusCode();
    }
    
    private static string DetermineIdpSource(string issuer)
    {
        if (issuer.Contains("microsoftonline.com") || issuer.Contains("sts.windows.net"))
            return "azure-ad";
        if (issuer.Contains("okta.com"))
            return "okta";
        if (issuer.Contains("keycloak"))
            return "keycloak";
        return "unknown";
    }
    
    private static string DetermineType(ClaimsPrincipal user)
    {
        var idtyp = user.FindFirstValue("idtyp");
        if (idtyp == "app") return "ServiceAccount";
        return "User";
    }
    
    // Response DTOs
    private record PermissionCheckResponse(
        bool IsAllowed,
        string? GrantedVia,
        string? Role,
        string? MatchingScope);
    
    private record EffectivePermissionsResponse(
        string PrincipalId,
        string Scope,
        List<RoleDto> Roles,
        List<string> Permissions);
    
    private record RoleDto(string Name, string AssignedScope, string GrantedVia);
    
    private record AssignmentResponse(Guid Id);
}
```

### CachedAuthorizationService

```csharp
/// <summary>
/// Wrapper avec cache local pour rÃ©duire les appels HTTP.
/// </summary>
public class CachedAuthorizationService : IAuthorizationService
{
    private readonly IAuthorizationService _inner;
    private readonly IMemoryCache _cache;
    private readonly TimeSpan _cacheDuration = TimeSpan.FromMinutes(2);
    
    public CachedAuthorizationService(
        AuthorizationService inner,
        IMemoryCache cache)
    {
        _inner = inner;
        _cache = cache;
    }
    
    public async Task<bool> CheckPermissionAsync(
        Guid principalId,
        string action,
        string resourceType,
        string scope,
        CancellationToken ct = default)
    {
        var cacheKey = $"perm:{principalId}:{action}:{resourceType}:{scope}";
        
        if (_cache.TryGetValue<bool>(cacheKey, out var cached))
        {
            return cached;
        }
        
        var result = await _inner.CheckPermissionAsync(principalId, action, resourceType, scope, ct);
        
        _cache.Set(cacheKey, result, _cacheDuration);
        
        return result;
    }
    
    public Task<PermissionCheckResult> CheckPermissionDetailedAsync(
        Guid principalId,
        string action,
        string resourceType,
        string scope,
        CancellationToken ct = default)
        => _inner.CheckPermissionDetailedAsync(principalId, action, resourceType, scope, ct);
    
    public Task<EffectivePermissionsResult> GetEffectivePermissionsAsync(
        Guid principalId,
        string scope,
        CancellationToken ct = default)
        => _inner.GetEffectivePermissionsAsync(principalId, scope, ct);
    
    public async Task<AssignmentResult> AssignRoleAsync(
        Guid principalId,
        string roleName,
        string scope,
        Guid assignedBy,
        DateTime? expiresAt = null,
        CancellationToken ct = default)
    {
        var result = await _inner.AssignRoleAsync(principalId, roleName, scope, assignedBy, expiresAt, ct);
        
        // Invalider le cache pour ce principal
        InvalidatePrincipalCache(principalId);
        
        return result;
    }
    
    public async Task RevokeAssignmentAsync(Guid assignmentId, CancellationToken ct = default)
    {
        await _inner.RevokeAssignmentAsync(assignmentId, ct);
        // Note: IdÃ©alement rÃ©cupÃ©rer le principalId pour invalider le cache
    }
    
    public Task SyncPrincipalAsync(ClaimsPrincipal user, CancellationToken ct = default)
        => _inner.SyncPrincipalAsync(user, ct);
    
    private void InvalidatePrincipalCache(Guid principalId)
    {
        // IMemoryCache ne supporte pas la suppression par pattern
        // Alternative: utiliser un token de cancellation ou MemoryCacheEntryOptions
    }
}
```

### RequirePermissionAttribute

```csharp
/// <summary>
/// Attribut pour exiger une permission sur un controller/action.
/// </summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]
public class RequirePermissionAttribute : Attribute, IAuthorizationFilter
{
    public string Action { get; }
    public string ResourceType { get; }
    public string? ScopeTemplate { get; }
    
    /// <summary>
    /// CrÃ©e une exigence de permission.
    /// </summary>
    /// <param name="action">Action requise (read, write, delete, admin)</param>
    /// <param name="resourceType">Type de ressource (providers, routes, tenants)</param>
    /// <param name="scopeTemplate">Template de scope avec placeholders (ex: "api.llmproxy.com/organizations/{organizationId}/tenants/{tenantId}")</param>
    public RequirePermissionAttribute(string action, string resourceType, string? scopeTemplate = null)
    {
        Action = action;
        ResourceType = resourceType;
        ScopeTemplate = scopeTemplate;
    }
    
    public void OnAuthorization(AuthorizationFilterContext context)
    {
        // L'Ã©valuation rÃ©elle est faite par PermissionAuthorizationHandler
        // Cet attribut ne fait que marquer le besoin
    }
}
```

### PermissionAuthorizationHandler

```csharp
/// <summary>
/// Handler qui Ã©value les permissions via l'Authorization Service.
/// </summary>
public class PermissionAuthorizationHandler : IAuthorizationHandler
{
    private readonly IAuthorizationService _authService;
    private readonly IScopeResolver _scopeResolver;
    private readonly ILogger<PermissionAuthorizationHandler> _logger;
    
    public PermissionAuthorizationHandler(
        IAuthorizationService authService,
        IScopeResolver scopeResolver,
        ILogger<PermissionAuthorizationHandler> logger)
    {
        _authService = authService;
        _scopeResolver = scopeResolver;
        _logger = logger;
    }
    
    public async Task HandleAsync(AuthorizationHandlerContext context)
    {
        var httpContext = context.Resource as HttpContext;
        if (httpContext == null) return;
        
        var endpoint = httpContext.GetEndpoint();
        var requirePermissions = endpoint?.Metadata
            .GetOrderedMetadata<RequirePermissionAttribute>();
        
        if (requirePermissions == null || !requirePermissions.Any())
        {
            context.Succeed(new PassThroughRequirement());
            return;
        }
        
        var principalId = GetPrincipalId(context.User);
        if (principalId == null)
        {
            context.Fail();
            return;
        }
        
        foreach (var requirement in requirePermissions)
        {
            var scope = ResolveScopeFromRequest(httpContext, requirement.ScopeTemplate);
            
            var isAllowed = await _authService.CheckPermissionAsync(
                principalId.Value,
                requirement.Action,
                requirement.ResourceType,
                scope,
                httpContext.RequestAborted);
            
            if (!isAllowed)
            {
                _logger.LogWarning(
                    "Permission denied: Principal={PrincipalId}, Action={Action}, Resource={Resource}, Scope={Scope}",
                    principalId, requirement.Action, requirement.ResourceType, scope);
                
                context.Fail();
                return;
            }
        }
        
        context.Succeed(new PassThroughRequirement());
    }
    
    private Guid? GetPrincipalId(ClaimsPrincipal user)
    {
        var oid = user.FindFirstValue("oid") ?? user.FindFirstValue("sub");
        return Guid.TryParse(oid, out var id) ? id : null;
    }
    
    private string ResolveScopeFromRequest(HttpContext context, string? scopeTemplate)
    {
        if (string.IsNullOrEmpty(scopeTemplate))
        {
            return _scopeResolver.ResolveFromRequest(context);
        }
        
        // Remplacer les placeholders par les valeurs de la route
        var scope = scopeTemplate;
        foreach (var routeValue in context.Request.RouteValues)
        {
            scope = scope.Replace($"{{{routeValue.Key}}}", routeValue.Value?.ToString() ?? "");
        }
        
        return scope;
    }
}

public class PassThroughRequirement : IAuthorizationRequirement { }
```

### IScopeResolver

```csharp
/// <summary>
/// RÃ©sout le scope URL REST depuis la requÃªte HTTP.
/// </summary>
public interface IScopeResolver
{
    /// <summary>
    /// DÃ©termine le scope depuis l'URL et les headers.
    /// </summary>
    string ResolveFromRequest(HttpContext context);
}

public class DefaultScopeResolver : IScopeResolver
{
    private readonly string _domain;
    
    public DefaultScopeResolver(IConfiguration configuration)
    {
        _domain = configuration["Authorization:ScopeDomain"] ?? "api.llmproxy.com";
    }
    
    public string ResolveFromRequest(HttpContext context)
    {
        // Construire le scope depuis les route values
        var segments = new List<string> { _domain };
        
        // Extraire organization, tenant, etc. depuis les headers ou route
        if (context.Request.Headers.TryGetValue("X-Organization-Id", out var orgId))
        {
            segments.Add("organizations");
            segments.Add(orgId.ToString());
        }
        
        if (context.Request.Headers.TryGetValue("X-Tenant-Id", out var tenantId))
        {
            segments.Add("tenants");
            segments.Add(tenantId.ToString());
        }
        
        // Ou depuis les route values
        if (context.Request.RouteValues.TryGetValue("organizationId", out var routeOrgId))
        {
            if (!segments.Contains("organizations"))
            {
                segments.Add("organizations");
                segments.Add(routeOrgId?.ToString() ?? "");
            }
        }
        
        if (context.Request.RouteValues.TryGetValue("tenantId", out var routeTenantId))
        {
            if (!segments.Contains("tenants"))
            {
                segments.Add("tenants");
                segments.Add(routeTenantId?.ToString() ?? "");
            }
        }
        
        if (context.Request.RouteValues.TryGetValue("providerId", out var providerId))
        {
            segments.Add("providers");
            segments.Add(providerId?.ToString() ?? "");
        }
        
        return string.Join("/", segments);
    }
}
```

### Dependency Injection

```csharp
public static class DependencyInjection
{
    public static IServiceCollection AddAuthorizationClient(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var options = configuration
            .GetSection("Authorization")
            .Get<AuthorizationClientOptions>()!;
        
        // HTTP Client pour Authorization API
        services.AddHttpClient<AuthorizationService>(client =>
        {
            client.BaseAddress = new Uri(options.BaseUrl);
            client.DefaultRequestHeaders.Add("Accept", "application/json");
        });
        
        // Service avec cache
        services.AddMemoryCache();
        services.AddScoped<IAuthorizationService>(sp =>
        {
            var inner = sp.GetRequiredService<AuthorizationService>();
            var cache = sp.GetRequiredService<IMemoryCache>();
            return new CachedAuthorizationService(inner, cache);
        });
        
        // Scope resolver
        services.AddScoped<IScopeResolver, DefaultScopeResolver>();
        
        // Authorization handler
        services.AddScoped<IAuthorizationHandler, PermissionAuthorizationHandler>();
        
        // Policy
        services.AddAuthorization(options =>
        {
            options.DefaultPolicy = new AuthorizationPolicyBuilder()
                .RequireAuthenticatedUser()
                .AddRequirements(new PassThroughRequirement())
                .Build();
        });
        
        return services;
    }
}

public class AuthorizationClientOptions
{
    public string BaseUrl { get; set; } = "http://localhost:5100";
    public string ScopeDomain { get; set; } = "api.llmproxy.com";
}
```

### Exemple d'utilisation dans un Controller

```csharp
[ApiController]
[Route("api/v1/organizations/{organizationId}/tenants/{tenantId}/providers")]
[Authorize]
public class ProvidersController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public ProvidersController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    [HttpGet]
    [RequirePermission("read", "providers", 
        "api.llmproxy.com/organizations/{organizationId}/tenants/{tenantId}")]
    public async Task<IActionResult> ListProviders(
        [FromRoute] string organizationId,
        [FromRoute] string tenantId,
        CancellationToken ct)
    {
        // Le middleware a dÃ©jÃ  vÃ©rifiÃ© la permission
        var query = new ListProvidersQuery(organizationId, tenantId);
        var result = await _mediator.Send(query, ct);
        return Ok(result);
    }
    
    [HttpPost]
    [RequirePermission("write", "providers", 
        "api.llmproxy.com/organizations/{organizationId}/tenants/{tenantId}")]
    public async Task<IActionResult> CreateProvider(
        [FromRoute] string organizationId,
        [FromRoute] string tenantId,
        [FromBody] CreateProviderRequest request,
        CancellationToken ct)
    {
        var command = new CreateProviderCommand(organizationId, tenantId, request);
        var result = await _mediator.Send(command, ct);
        return CreatedAtAction(nameof(GetProvider), new { id = result.Id }, result);
    }
    
    [HttpDelete("{providerId}")]
    [RequirePermission("delete", "providers", 
        "api.llmproxy.com/organizations/{organizationId}/tenants/{tenantId}/providers/{providerId}")]
    public async Task<IActionResult> DeleteProvider(
        [FromRoute] string organizationId,
        [FromRoute] string tenantId,
        [FromRoute] string providerId,
        CancellationToken ct)
    {
        var command = new DeleteProviderCommand(organizationId, tenantId, providerId);
        await _mediator.Send(command, ct);
        return NoContent();
    }
}
```

## CRITÃˆRES DE SUCCÃˆS

- [ ] Projet crÃ©Ã© dans `backend/src/Infrastructure/LLMProxy.Infrastructure.Authorization/`
- [ ] IAuthorizationService implÃ©mentÃ© avec HTTP client
- [ ] CachedAuthorizationService fonctionnel
- [ ] RequirePermissionAttribute utilisable
- [ ] PermissionAuthorizationHandler intÃ©grÃ©
- [ ] IScopeResolver rÃ©sout les scopes depuis les requÃªtes
- [ ] Configuration via appsettings.json
- [ ] Tests unitaires avec mocks HTTP
- [ ] Tests d'intÃ©gration avec Authorization API
- [ ] Build : 0 erreurs, 0 warnings

## ESTIMATION

**Effort** : 4h
**ComplexitÃ©** : Moyenne

## TRACKING
