# TÃ¢che 067.7 - Authorization Cleanup Job (Expiration)

## PRIORITÃ‰
ğŸŸ¡ **P3 - MOYENNE** (DÃ©pend de 067.3)

## OBJECTIF

ImplÃ©menter un Background Service pour purger les assignations de rÃ´les expirÃ©es.

## DÃ‰PENDANCES

- âœ… **067.3** - Application Layer (RoleAssignmentService)

## DÃ‰CISION DE CADRAGE

**Expiration optionnelle** : Les assignations peuvent avoir une date d'expiration optionnelle (`ExpiresAt`). Un cleanup job purge les assignations expirÃ©es toutes les 5 minutes.

## ARCHITECTURE

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ExpirationCleanupJob                            â”‚
â”‚                  (BackgroundService)                             â”‚
â”‚                                                                  â”‚
â”‚   1. Lire tous les tuples avec condition d'expiration           â”‚
â”‚   2. Identifier les tuples expirÃ©s                              â”‚
â”‚   3. Supprimer les tuples expirÃ©s dans OpenFGA                  â”‚
â”‚   4. Invalider le cache Redis                                   â”‚
â”‚   5. Logger les suppressions (audit)                            â”‚
â”‚   6. Attendre 5 minutes                                         â”‚
â”‚   7. RÃ©pÃ©ter                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## STRUCTURE DE FICHIERS

```
authorization/src/Authorization.Application/
â”œâ”€â”€ Jobs/
â”‚   â”œâ”€â”€ ExpirationCleanupJob.cs
â”‚   â””â”€â”€ ExpirationCleanupOptions.cs

authorization/src/Authorization.Infrastructure/
â”œâ”€â”€ Persistence/
â”‚   â””â”€â”€ ExpirationStore.cs  # Stockage des dates d'expiration
```

## IMPLÃ‰MENTATION

### Stockage des Expirations

Les dates d'expiration sont stockÃ©es dans OpenFGA via des tuples conditionnels ou dans une table PostgreSQL dÃ©diÃ©e (plus simple pour les requÃªtes).

```sql
-- Table pour tracker les expirations
CREATE TABLE assignment_expirations (
    id BIGSERIAL PRIMARY KEY,
    tenant_id VARCHAR(100) NOT NULL,
    principal_id UUID NOT NULL,
    principal_type VARCHAR(50) NOT NULL,
    role VARCHAR(100) NOT NULL,
    scope TEXT NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (tenant_id, principal_id, role, scope)
);

CREATE INDEX idx_expirations_expires_at ON assignment_expirations(expires_at);
CREATE INDEX idx_expirations_tenant ON assignment_expirations(tenant_id);
```

### Cleanup Job

```csharp
// Jobs/ExpirationCleanupJob.cs
public sealed class ExpirationCleanupJob : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ExpirationCleanupJob> _logger;
    private readonly ExpirationCleanupOptions _options;
    
    public ExpirationCleanupJob(
        IServiceScopeFactory scopeFactory,
        IOptions<ExpirationCleanupOptions> options,
        ILogger<ExpirationCleanupJob> logger)
    {
        _scopeFactory = scopeFactory;
        _options = options.Value;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Expiration cleanup job started");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await CleanupExpiredAssignmentsAsync(stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during expiration cleanup");
            }
            
            await Task.Delay(_options.Interval, stoppingToken);
        }
    }
    
    private async Task CleanupExpiredAssignmentsAsync(CancellationToken ct)
    {
        using var scope = _scopeFactory.CreateScope();
        var expirationStore = scope.ServiceProvider.GetRequiredService<IExpirationStore>();
        var openFga = scope.ServiceProvider.GetRequiredService<IOpenFgaService>();
        var cache = scope.ServiceProvider.GetRequiredService<IPermissionCache>();
        var audit = scope.ServiceProvider.GetRequiredService<IAuditService>();
        
        var now = DateTimeOffset.UtcNow;
        var expiredAssignments = await expirationStore.GetExpiredAsync(now, ct);
        
        if (!expiredAssignments.Any())
        {
            _logger.LogDebug("No expired assignments found");
            return;
        }
        
        _logger.LogInformation("Found {Count} expired assignments to cleanup", expiredAssignments.Count);
        
        foreach (var assignment in expiredAssignments)
        {
            try
            {
                // 1. Supprimer le tuple dans OpenFGA
                var tuple = assignment.PrincipalType switch
                {
                    "User" => TupleBuilder.UserAssignment(
                        assignment.PrincipalId, assignment.Role, Scope.Parse(assignment.Scope)),
                    "Group" => TupleBuilder.GroupAssignment(
                        assignment.PrincipalId, assignment.Role, Scope.Parse(assignment.Scope)),
                    "ServiceAccount" => new TupleKey(
                        $"serviceaccount:{assignment.PrincipalId}",
                        assignment.Role,
                        $"scope:{assignment.Scope}"),
                    _ => throw new InvalidOperationException()
                };
                
                await openFga.DeleteTuplesAsync([tuple], ct);
                
                // 2. Invalider le cache
                await cache.InvalidateUserAsync($"user:{assignment.PrincipalId}", ct);
                
                // 3. Supprimer l'entrÃ©e d'expiration
                await expirationStore.DeleteAsync(assignment.Id, ct);
                
                // 4. Audit
                await audit.LogExpirationAsync(assignment, ct);
                
                _logger.LogInformation(
                    "Cleaned up expired assignment: {Role} on {Scope} for {Principal}",
                    assignment.Role, assignment.Scope, assignment.PrincipalId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, 
                    "Failed to cleanup assignment {Id}", assignment.Id);
            }
        }
    }
}

// Jobs/ExpirationCleanupOptions.cs
public sealed class ExpirationCleanupOptions
{
    public TimeSpan Interval { get; set; } = TimeSpan.FromMinutes(5);
    public int BatchSize { get; set; } = 100;
}
```

### Interface IExpirationStore

```csharp
// Persistence/IExpirationStore.cs
public interface IExpirationStore
{
    Task CreateAsync(AssignmentExpiration expiration, CancellationToken ct = default);
    Task<IReadOnlyList<AssignmentExpiration>> GetExpiredAsync(DateTimeOffset asOf, CancellationToken ct = default);
    Task DeleteAsync(long id, CancellationToken ct = default);
    Task DeleteByAssignmentAsync(Guid principalId, string role, string scope, CancellationToken ct = default);
}

public sealed record AssignmentExpiration(
    long Id,
    string TenantId,
    Guid PrincipalId,
    string PrincipalType,
    string Role,
    string Scope,
    DateTimeOffset ExpiresAt);
```

### Registration

```csharp
// DependencyInjection.cs
public static IServiceCollection AddExpirationCleanup(
    this IServiceCollection services,
    IConfiguration configuration)
{
    services.Configure<ExpirationCleanupOptions>(
        configuration.GetSection("ExpirationCleanup"));
    
    services.AddHostedService<ExpirationCleanupJob>();
    services.AddScoped<IExpirationStore, ExpirationStore>();
    
    return services;
}
```

## TESTS

```csharp
[Fact]
public async Task CleanupJob_RemovesExpiredAssignments()
{
    // Arrange
    var expiredAssignment = new AssignmentExpiration(
        1, "tenant-1", Guid.NewGuid(), "User", "reader",
        "api.llmproxy.com/organizations/org-123",
        DateTimeOffset.UtcNow.AddMinutes(-10));
    
    var expirationStore = Substitute.For<IExpirationStore>();
    expirationStore.GetExpiredAsync(Arg.Any<DateTimeOffset>())
        .Returns([expiredAssignment]);
    
    var openFga = Substitute.For<IOpenFgaService>();
    var cache = Substitute.For<IPermissionCache>();
    var audit = Substitute.For<IAuditService>();
    
    // Act
    await job.CleanupExpiredAssignmentsAsync(CancellationToken.None);
    
    // Assert
    await openFga.Received(1).DeleteTuplesAsync(Arg.Any<IEnumerable<TupleKey>>());
    await cache.Received(1).InvalidateUserAsync(Arg.Any<string>());
    await expirationStore.Received(1).DeleteAsync(1);
    await audit.Received(1).LogExpirationAsync(expiredAssignment);
}

[Fact]
public async Task CleanupJob_SkipsWhenNoExpiredAssignments()
{
    // Arrange
    var expirationStore = Substitute.For<IExpirationStore>();
    expirationStore.GetExpiredAsync(Arg.Any<DateTimeOffset>())
        .Returns([]);
    
    var openFga = Substitute.For<IOpenFgaService>();
    
    // Act
    await job.CleanupExpiredAssignmentsAsync(CancellationToken.None);
    
    // Assert
    await openFga.DidNotReceive().DeleteTuplesAsync(Arg.Any<IEnumerable<TupleKey>>());
}
```

## CRITÃˆRES DE SUCCÃˆS

- [ ] ExpirationCleanupJob implÃ©mentÃ© comme BackgroundService
- [ ] Table `assignment_expirations` crÃ©Ã©e
- [ ] IExpirationStore implÃ©mentÃ©
- [ ] Suppression des tuples OpenFGA expirÃ©s
- [ ] Invalidation du cache Redis
- [ ] Logging des suppressions
- [ ] Audit des expirations
- [ ] Configuration de l'intervalle (default 5 min)
- [ ] Tests unitaires
- [ ] Build : 0 erreurs, 0 warnings

## ESTIMATION

**Effort** : 4h
**ComplexitÃ©** : Moyenne

## RÃ‰FÃ‰RENCES

- [ADR-060](../docs/adr/060-authorization-azure-rbac-style.adr.md)
- [BackgroundService](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services)
